
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model administracion
 * 
 */
export type administracion = {
  DNI_Admin: number
  Nombre: string
  Apellido: string
  Mail: string
  Contrasena: string
}

/**
 * Model alumno
 * 
 */
export type alumno = {
  Dni_Alumno: number
  Nombre: string | null
  Apellido: string | null
  Mail: string | null
  contrasena: string
}

/**
 * Model Clase
 * 
 */
export type Clase = {
  Clase_ID: number
  Division_ID: number
  Materia_ID: number
  Profesor_ID: number
  Fecha_Comienzo: Date | null
  Fecha_Final: Date | null
}

/**
 * Model division
 * 
 */
export type division = {
  Division_ID: number
  Ano_Escolar: string
  Division_Escolar: number
  Turno: string
}

/**
 * Model divison_de_alumno
 * 
 */
export type divison_de_alumno = {
  DivisionDA_ID: number
  DNi_Alumno: number | null
  Division_ID: number
  Anio_Calendario: number
}

/**
 * Model evaluaciones
 * 
 */
export type evaluaciones = {
  Evaluacion_ID: number
  Clase_ID: number
  Fecha: Date | null
  Detalles: string
}

/**
 * Model faltas
 * 
 */
export type faltas = {
  Falta_ID: number
  DNI_Alumno: number
  Fecha: Date | null
  Tipo: Prisma.Decimal
  jutificada: boolean
}

/**
 * Model materia
 * 
 */
export type materia = {
  Materia_ID: number
  Nombre: string
  Ano_escolar: number
  Horas_Semanales: number
}

/**
 * Model notas
 * 
 */
export type notas = {
  Notas_ID: number
  Nota: Prisma.Decimal
  DNI_Alumno: number
  Evaluacion_ID: number
}

/**
 * Model profesor
 * 
 */
export type profesor = {
  DNI_Profesor: number
  Nombre: string
  Apellido: string
  Mail: string
  Contrasena: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Administracions
 * const administracions = await prisma.administracion.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Administracions
   * const administracions = await prisma.administracion.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.administracion`: Exposes CRUD operations for the **administracion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Administracions
    * const administracions = await prisma.administracion.findMany()
    * ```
    */
  get administracion(): Prisma.administracionDelegate<GlobalReject>;

  /**
   * `prisma.alumno`: Exposes CRUD operations for the **alumno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alumnos
    * const alumnos = await prisma.alumno.findMany()
    * ```
    */
  get alumno(): Prisma.alumnoDelegate<GlobalReject>;

  /**
   * `prisma.clase`: Exposes CRUD operations for the **Clase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clases
    * const clases = await prisma.clase.findMany()
    * ```
    */
  get clase(): Prisma.ClaseDelegate<GlobalReject>;

  /**
   * `prisma.division`: Exposes CRUD operations for the **division** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Divisions
    * const divisions = await prisma.division.findMany()
    * ```
    */
  get division(): Prisma.divisionDelegate<GlobalReject>;

  /**
   * `prisma.divison_de_alumno`: Exposes CRUD operations for the **divison_de_alumno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Divison_de_alumnos
    * const divison_de_alumnos = await prisma.divison_de_alumno.findMany()
    * ```
    */
  get divison_de_alumno(): Prisma.divison_de_alumnoDelegate<GlobalReject>;

  /**
   * `prisma.evaluaciones`: Exposes CRUD operations for the **evaluaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluaciones
    * const evaluaciones = await prisma.evaluaciones.findMany()
    * ```
    */
  get evaluaciones(): Prisma.evaluacionesDelegate<GlobalReject>;

  /**
   * `prisma.faltas`: Exposes CRUD operations for the **faltas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faltas
    * const faltas = await prisma.faltas.findMany()
    * ```
    */
  get faltas(): Prisma.faltasDelegate<GlobalReject>;

  /**
   * `prisma.materia`: Exposes CRUD operations for the **materia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materias
    * const materias = await prisma.materia.findMany()
    * ```
    */
  get materia(): Prisma.materiaDelegate<GlobalReject>;

  /**
   * `prisma.notas`: Exposes CRUD operations for the **notas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notas
    * const notas = await prisma.notas.findMany()
    * ```
    */
  get notas(): Prisma.notasDelegate<GlobalReject>;

  /**
   * `prisma.profesor`: Exposes CRUD operations for the **profesor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profesors
    * const profesors = await prisma.profesor.findMany()
    * ```
    */
  get profesor(): Prisma.profesorDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.13.0
   * Query Engine version: b20ead4d3ab9e78ac112966e242ded703f4a052c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    administracion: 'administracion',
    alumno: 'alumno',
    Clase: 'Clase',
    division: 'division',
    divison_de_alumno: 'divison_de_alumno',
    evaluaciones: 'evaluaciones',
    faltas: 'faltas',
    materia: 'materia',
    notas: 'notas',
    profesor: 'profesor'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AlumnoCountOutputType
   */


  export type AlumnoCountOutputType = {
    divisiones: number
    notas: number
    faltas: number
  }

  export type AlumnoCountOutputTypeSelect = {
    divisiones?: boolean | AlumnoCountOutputTypeCountDivisionesArgs
    notas?: boolean | AlumnoCountOutputTypeCountNotasArgs
    faltas?: boolean | AlumnoCountOutputTypeCountFaltasArgs
  }

  export type AlumnoCountOutputTypeGetPayload<S extends boolean | null | undefined | AlumnoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AlumnoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AlumnoCountOutputTypeArgs)
    ? AlumnoCountOutputType 
    : S extends { select: any } & (AlumnoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AlumnoCountOutputType ? AlumnoCountOutputType[P] : never
  } 
      : AlumnoCountOutputType




  // Custom InputTypes

  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AlumnoCountOutputType
     */
    select?: AlumnoCountOutputTypeSelect | null
  }


  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountDivisionesArgs = {
    where?: divison_de_alumnoWhereInput
  }


  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountNotasArgs = {
    where?: notasWhereInput
  }


  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountFaltasArgs = {
    where?: faltasWhereInput
  }



  /**
   * Count Type DivisionCountOutputType
   */


  export type DivisionCountOutputType = {
    Materias: number
  }

  export type DivisionCountOutputTypeSelect = {
    Materias?: boolean | DivisionCountOutputTypeCountMateriasArgs
  }

  export type DivisionCountOutputTypeGetPayload<S extends boolean | null | undefined | DivisionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DivisionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DivisionCountOutputTypeArgs)
    ? DivisionCountOutputType 
    : S extends { select: any } & (DivisionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DivisionCountOutputType ? DivisionCountOutputType[P] : never
  } 
      : DivisionCountOutputType




  // Custom InputTypes

  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DivisionCountOutputType
     */
    select?: DivisionCountOutputTypeSelect | null
  }


  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeCountMateriasArgs = {
    where?: ClaseWhereInput
  }



  /**
   * Count Type MateriaCountOutputType
   */


  export type MateriaCountOutputType = {
    cursos: number
  }

  export type MateriaCountOutputTypeSelect = {
    cursos?: boolean | MateriaCountOutputTypeCountCursosArgs
  }

  export type MateriaCountOutputTypeGetPayload<S extends boolean | null | undefined | MateriaCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MateriaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MateriaCountOutputTypeArgs)
    ? MateriaCountOutputType 
    : S extends { select: any } & (MateriaCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MateriaCountOutputType ? MateriaCountOutputType[P] : never
  } 
      : MateriaCountOutputType




  // Custom InputTypes

  /**
   * MateriaCountOutputType without action
   */
  export type MateriaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MateriaCountOutputType
     */
    select?: MateriaCountOutputTypeSelect | null
  }


  /**
   * MateriaCountOutputType without action
   */
  export type MateriaCountOutputTypeCountCursosArgs = {
    where?: ClaseWhereInput
  }



  /**
   * Count Type ProfesorCountOutputType
   */


  export type ProfesorCountOutputType = {
    cursos: number
  }

  export type ProfesorCountOutputTypeSelect = {
    cursos?: boolean | ProfesorCountOutputTypeCountCursosArgs
  }

  export type ProfesorCountOutputTypeGetPayload<S extends boolean | null | undefined | ProfesorCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProfesorCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProfesorCountOutputTypeArgs)
    ? ProfesorCountOutputType 
    : S extends { select: any } & (ProfesorCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProfesorCountOutputType ? ProfesorCountOutputType[P] : never
  } 
      : ProfesorCountOutputType




  // Custom InputTypes

  /**
   * ProfesorCountOutputType without action
   */
  export type ProfesorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProfesorCountOutputType
     */
    select?: ProfesorCountOutputTypeSelect | null
  }


  /**
   * ProfesorCountOutputType without action
   */
  export type ProfesorCountOutputTypeCountCursosArgs = {
    where?: ClaseWhereInput
  }



  /**
   * Models
   */

  /**
   * Model administracion
   */


  export type AggregateAdministracion = {
    _count: AdministracionCountAggregateOutputType | null
    _avg: AdministracionAvgAggregateOutputType | null
    _sum: AdministracionSumAggregateOutputType | null
    _min: AdministracionMinAggregateOutputType | null
    _max: AdministracionMaxAggregateOutputType | null
  }

  export type AdministracionAvgAggregateOutputType = {
    DNI_Admin: number | null
  }

  export type AdministracionSumAggregateOutputType = {
    DNI_Admin: number | null
  }

  export type AdministracionMinAggregateOutputType = {
    DNI_Admin: number | null
    Nombre: string | null
    Apellido: string | null
    Mail: string | null
    Contrasena: string | null
  }

  export type AdministracionMaxAggregateOutputType = {
    DNI_Admin: number | null
    Nombre: string | null
    Apellido: string | null
    Mail: string | null
    Contrasena: string | null
  }

  export type AdministracionCountAggregateOutputType = {
    DNI_Admin: number
    Nombre: number
    Apellido: number
    Mail: number
    Contrasena: number
    _all: number
  }


  export type AdministracionAvgAggregateInputType = {
    DNI_Admin?: true
  }

  export type AdministracionSumAggregateInputType = {
    DNI_Admin?: true
  }

  export type AdministracionMinAggregateInputType = {
    DNI_Admin?: true
    Nombre?: true
    Apellido?: true
    Mail?: true
    Contrasena?: true
  }

  export type AdministracionMaxAggregateInputType = {
    DNI_Admin?: true
    Nombre?: true
    Apellido?: true
    Mail?: true
    Contrasena?: true
  }

  export type AdministracionCountAggregateInputType = {
    DNI_Admin?: true
    Nombre?: true
    Apellido?: true
    Mail?: true
    Contrasena?: true
    _all?: true
  }

  export type AdministracionAggregateArgs = {
    /**
     * Filter which administracion to aggregate.
     */
    where?: administracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administracions to fetch.
     */
    orderBy?: Enumerable<administracionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: administracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned administracions
    **/
    _count?: true | AdministracionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdministracionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdministracionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministracionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministracionMaxAggregateInputType
  }

  export type GetAdministracionAggregateType<T extends AdministracionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministracion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministracion[P]>
      : GetScalarType<T[P], AggregateAdministracion[P]>
  }




  export type AdministracionGroupByArgs = {
    where?: administracionWhereInput
    orderBy?: Enumerable<administracionOrderByWithAggregationInput>
    by: AdministracionScalarFieldEnum[]
    having?: administracionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministracionCountAggregateInputType | true
    _avg?: AdministracionAvgAggregateInputType
    _sum?: AdministracionSumAggregateInputType
    _min?: AdministracionMinAggregateInputType
    _max?: AdministracionMaxAggregateInputType
  }


  export type AdministracionGroupByOutputType = {
    DNI_Admin: number
    Nombre: string
    Apellido: string
    Mail: string
    Contrasena: string
    _count: AdministracionCountAggregateOutputType | null
    _avg: AdministracionAvgAggregateOutputType | null
    _sum: AdministracionSumAggregateOutputType | null
    _min: AdministracionMinAggregateOutputType | null
    _max: AdministracionMaxAggregateOutputType | null
  }

  type GetAdministracionGroupByPayload<T extends AdministracionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AdministracionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdministracionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdministracionGroupByOutputType[P]>
            : GetScalarType<T[P], AdministracionGroupByOutputType[P]>
        }
      >
    >


  export type administracionSelect = {
    DNI_Admin?: boolean
    Nombre?: boolean
    Apellido?: boolean
    Mail?: boolean
    Contrasena?: boolean
  }


  export type administracionGetPayload<S extends boolean | null | undefined | administracionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? administracion :
    S extends undefined ? never :
    S extends { include: any } & (administracionArgs | administracionFindManyArgs)
    ? administracion 
    : S extends { select: any } & (administracionArgs | administracionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof administracion ? administracion[P] : never
  } 
      : administracion


  type administracionCountArgs = 
    Omit<administracionFindManyArgs, 'select' | 'include'> & {
      select?: AdministracionCountAggregateInputType | true
    }

  export interface administracionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Administracion that matches the filter.
     * @param {administracionFindUniqueArgs} args - Arguments to find a Administracion
     * @example
     * // Get one Administracion
     * const administracion = await prisma.administracion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends administracionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, administracionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'administracion'> extends True ? Prisma__administracionClient<administracionGetPayload<T>> : Prisma__administracionClient<administracionGetPayload<T> | null, null>

    /**
     * Find one Administracion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {administracionFindUniqueOrThrowArgs} args - Arguments to find a Administracion
     * @example
     * // Get one Administracion
     * const administracion = await prisma.administracion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends administracionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, administracionFindUniqueOrThrowArgs>
    ): Prisma__administracionClient<administracionGetPayload<T>>

    /**
     * Find the first Administracion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administracionFindFirstArgs} args - Arguments to find a Administracion
     * @example
     * // Get one Administracion
     * const administracion = await prisma.administracion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends administracionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, administracionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'administracion'> extends True ? Prisma__administracionClient<administracionGetPayload<T>> : Prisma__administracionClient<administracionGetPayload<T> | null, null>

    /**
     * Find the first Administracion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administracionFindFirstOrThrowArgs} args - Arguments to find a Administracion
     * @example
     * // Get one Administracion
     * const administracion = await prisma.administracion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends administracionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, administracionFindFirstOrThrowArgs>
    ): Prisma__administracionClient<administracionGetPayload<T>>

    /**
     * Find zero or more Administracions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administracionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Administracions
     * const administracions = await prisma.administracion.findMany()
     * 
     * // Get first 10 Administracions
     * const administracions = await prisma.administracion.findMany({ take: 10 })
     * 
     * // Only select the `DNI_Admin`
     * const administracionWithDNI_AdminOnly = await prisma.administracion.findMany({ select: { DNI_Admin: true } })
     * 
    **/
    findMany<T extends administracionFindManyArgs>(
      args?: SelectSubset<T, administracionFindManyArgs>
    ): Prisma.PrismaPromise<Array<administracionGetPayload<T>>>

    /**
     * Create a Administracion.
     * @param {administracionCreateArgs} args - Arguments to create a Administracion.
     * @example
     * // Create one Administracion
     * const Administracion = await prisma.administracion.create({
     *   data: {
     *     // ... data to create a Administracion
     *   }
     * })
     * 
    **/
    create<T extends administracionCreateArgs>(
      args: SelectSubset<T, administracionCreateArgs>
    ): Prisma__administracionClient<administracionGetPayload<T>>

    /**
     * Create many Administracions.
     *     @param {administracionCreateManyArgs} args - Arguments to create many Administracions.
     *     @example
     *     // Create many Administracions
     *     const administracion = await prisma.administracion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends administracionCreateManyArgs>(
      args?: SelectSubset<T, administracionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Administracion.
     * @param {administracionDeleteArgs} args - Arguments to delete one Administracion.
     * @example
     * // Delete one Administracion
     * const Administracion = await prisma.administracion.delete({
     *   where: {
     *     // ... filter to delete one Administracion
     *   }
     * })
     * 
    **/
    delete<T extends administracionDeleteArgs>(
      args: SelectSubset<T, administracionDeleteArgs>
    ): Prisma__administracionClient<administracionGetPayload<T>>

    /**
     * Update one Administracion.
     * @param {administracionUpdateArgs} args - Arguments to update one Administracion.
     * @example
     * // Update one Administracion
     * const administracion = await prisma.administracion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends administracionUpdateArgs>(
      args: SelectSubset<T, administracionUpdateArgs>
    ): Prisma__administracionClient<administracionGetPayload<T>>

    /**
     * Delete zero or more Administracions.
     * @param {administracionDeleteManyArgs} args - Arguments to filter Administracions to delete.
     * @example
     * // Delete a few Administracions
     * const { count } = await prisma.administracion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends administracionDeleteManyArgs>(
      args?: SelectSubset<T, administracionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administracions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administracionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Administracions
     * const administracion = await prisma.administracion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends administracionUpdateManyArgs>(
      args: SelectSubset<T, administracionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Administracion.
     * @param {administracionUpsertArgs} args - Arguments to update or create a Administracion.
     * @example
     * // Update or create a Administracion
     * const administracion = await prisma.administracion.upsert({
     *   create: {
     *     // ... data to create a Administracion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Administracion we want to update
     *   }
     * })
    **/
    upsert<T extends administracionUpsertArgs>(
      args: SelectSubset<T, administracionUpsertArgs>
    ): Prisma__administracionClient<administracionGetPayload<T>>

    /**
     * Count the number of Administracions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administracionCountArgs} args - Arguments to filter Administracions to count.
     * @example
     * // Count the number of Administracions
     * const count = await prisma.administracion.count({
     *   where: {
     *     // ... the filter for the Administracions we want to count
     *   }
     * })
    **/
    count<T extends administracionCountArgs>(
      args?: Subset<T, administracionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministracionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Administracion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministracionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministracionAggregateArgs>(args: Subset<T, AdministracionAggregateArgs>): Prisma.PrismaPromise<GetAdministracionAggregateType<T>>

    /**
     * Group by Administracion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministracionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdministracionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdministracionGroupByArgs['orderBy'] }
        : { orderBy?: AdministracionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdministracionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministracionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for administracion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__administracionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * administracion base type for findUnique actions
   */
  export type administracionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the administracion
     */
    select?: administracionSelect | null
    /**
     * Filter, which administracion to fetch.
     */
    where: administracionWhereUniqueInput
  }

  /**
   * administracion findUnique
   */
  export interface administracionFindUniqueArgs extends administracionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * administracion findUniqueOrThrow
   */
  export type administracionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the administracion
     */
    select?: administracionSelect | null
    /**
     * Filter, which administracion to fetch.
     */
    where: administracionWhereUniqueInput
  }


  /**
   * administracion base type for findFirst actions
   */
  export type administracionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the administracion
     */
    select?: administracionSelect | null
    /**
     * Filter, which administracion to fetch.
     */
    where?: administracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administracions to fetch.
     */
    orderBy?: Enumerable<administracionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for administracions.
     */
    cursor?: administracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of administracions.
     */
    distinct?: Enumerable<AdministracionScalarFieldEnum>
  }

  /**
   * administracion findFirst
   */
  export interface administracionFindFirstArgs extends administracionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * administracion findFirstOrThrow
   */
  export type administracionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the administracion
     */
    select?: administracionSelect | null
    /**
     * Filter, which administracion to fetch.
     */
    where?: administracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administracions to fetch.
     */
    orderBy?: Enumerable<administracionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for administracions.
     */
    cursor?: administracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of administracions.
     */
    distinct?: Enumerable<AdministracionScalarFieldEnum>
  }


  /**
   * administracion findMany
   */
  export type administracionFindManyArgs = {
    /**
     * Select specific fields to fetch from the administracion
     */
    select?: administracionSelect | null
    /**
     * Filter, which administracions to fetch.
     */
    where?: administracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administracions to fetch.
     */
    orderBy?: Enumerable<administracionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing administracions.
     */
    cursor?: administracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administracions.
     */
    skip?: number
    distinct?: Enumerable<AdministracionScalarFieldEnum>
  }


  /**
   * administracion create
   */
  export type administracionCreateArgs = {
    /**
     * Select specific fields to fetch from the administracion
     */
    select?: administracionSelect | null
    /**
     * The data needed to create a administracion.
     */
    data: XOR<administracionCreateInput, administracionUncheckedCreateInput>
  }


  /**
   * administracion createMany
   */
  export type administracionCreateManyArgs = {
    /**
     * The data used to create many administracions.
     */
    data: Enumerable<administracionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * administracion update
   */
  export type administracionUpdateArgs = {
    /**
     * Select specific fields to fetch from the administracion
     */
    select?: administracionSelect | null
    /**
     * The data needed to update a administracion.
     */
    data: XOR<administracionUpdateInput, administracionUncheckedUpdateInput>
    /**
     * Choose, which administracion to update.
     */
    where: administracionWhereUniqueInput
  }


  /**
   * administracion updateMany
   */
  export type administracionUpdateManyArgs = {
    /**
     * The data used to update administracions.
     */
    data: XOR<administracionUpdateManyMutationInput, administracionUncheckedUpdateManyInput>
    /**
     * Filter which administracions to update
     */
    where?: administracionWhereInput
  }


  /**
   * administracion upsert
   */
  export type administracionUpsertArgs = {
    /**
     * Select specific fields to fetch from the administracion
     */
    select?: administracionSelect | null
    /**
     * The filter to search for the administracion to update in case it exists.
     */
    where: administracionWhereUniqueInput
    /**
     * In case the administracion found by the `where` argument doesn't exist, create a new administracion with this data.
     */
    create: XOR<administracionCreateInput, administracionUncheckedCreateInput>
    /**
     * In case the administracion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<administracionUpdateInput, administracionUncheckedUpdateInput>
  }


  /**
   * administracion delete
   */
  export type administracionDeleteArgs = {
    /**
     * Select specific fields to fetch from the administracion
     */
    select?: administracionSelect | null
    /**
     * Filter which administracion to delete.
     */
    where: administracionWhereUniqueInput
  }


  /**
   * administracion deleteMany
   */
  export type administracionDeleteManyArgs = {
    /**
     * Filter which administracions to delete
     */
    where?: administracionWhereInput
  }


  /**
   * administracion without action
   */
  export type administracionArgs = {
    /**
     * Select specific fields to fetch from the administracion
     */
    select?: administracionSelect | null
  }



  /**
   * Model alumno
   */


  export type AggregateAlumno = {
    _count: AlumnoCountAggregateOutputType | null
    _avg: AlumnoAvgAggregateOutputType | null
    _sum: AlumnoSumAggregateOutputType | null
    _min: AlumnoMinAggregateOutputType | null
    _max: AlumnoMaxAggregateOutputType | null
  }

  export type AlumnoAvgAggregateOutputType = {
    Dni_Alumno: number | null
  }

  export type AlumnoSumAggregateOutputType = {
    Dni_Alumno: number | null
  }

  export type AlumnoMinAggregateOutputType = {
    Dni_Alumno: number | null
    Nombre: string | null
    Apellido: string | null
    Mail: string | null
    contrasena: string | null
  }

  export type AlumnoMaxAggregateOutputType = {
    Dni_Alumno: number | null
    Nombre: string | null
    Apellido: string | null
    Mail: string | null
    contrasena: string | null
  }

  export type AlumnoCountAggregateOutputType = {
    Dni_Alumno: number
    Nombre: number
    Apellido: number
    Mail: number
    contrasena: number
    _all: number
  }


  export type AlumnoAvgAggregateInputType = {
    Dni_Alumno?: true
  }

  export type AlumnoSumAggregateInputType = {
    Dni_Alumno?: true
  }

  export type AlumnoMinAggregateInputType = {
    Dni_Alumno?: true
    Nombre?: true
    Apellido?: true
    Mail?: true
    contrasena?: true
  }

  export type AlumnoMaxAggregateInputType = {
    Dni_Alumno?: true
    Nombre?: true
    Apellido?: true
    Mail?: true
    contrasena?: true
  }

  export type AlumnoCountAggregateInputType = {
    Dni_Alumno?: true
    Nombre?: true
    Apellido?: true
    Mail?: true
    contrasena?: true
    _all?: true
  }

  export type AlumnoAggregateArgs = {
    /**
     * Filter which alumno to aggregate.
     */
    where?: alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumnos to fetch.
     */
    orderBy?: Enumerable<alumnoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alumnos
    **/
    _count?: true | AlumnoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlumnoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlumnoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlumnoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlumnoMaxAggregateInputType
  }

  export type GetAlumnoAggregateType<T extends AlumnoAggregateArgs> = {
        [P in keyof T & keyof AggregateAlumno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlumno[P]>
      : GetScalarType<T[P], AggregateAlumno[P]>
  }




  export type AlumnoGroupByArgs = {
    where?: alumnoWhereInput
    orderBy?: Enumerable<alumnoOrderByWithAggregationInput>
    by: AlumnoScalarFieldEnum[]
    having?: alumnoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlumnoCountAggregateInputType | true
    _avg?: AlumnoAvgAggregateInputType
    _sum?: AlumnoSumAggregateInputType
    _min?: AlumnoMinAggregateInputType
    _max?: AlumnoMaxAggregateInputType
  }


  export type AlumnoGroupByOutputType = {
    Dni_Alumno: number
    Nombre: string | null
    Apellido: string | null
    Mail: string | null
    contrasena: string
    _count: AlumnoCountAggregateOutputType | null
    _avg: AlumnoAvgAggregateOutputType | null
    _sum: AlumnoSumAggregateOutputType | null
    _min: AlumnoMinAggregateOutputType | null
    _max: AlumnoMaxAggregateOutputType | null
  }

  type GetAlumnoGroupByPayload<T extends AlumnoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AlumnoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlumnoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlumnoGroupByOutputType[P]>
            : GetScalarType<T[P], AlumnoGroupByOutputType[P]>
        }
      >
    >


  export type alumnoSelect = {
    Dni_Alumno?: boolean
    Nombre?: boolean
    Apellido?: boolean
    Mail?: boolean
    contrasena?: boolean
    divisiones?: boolean | alumno$divisionesArgs
    notas?: boolean | alumno$notasArgs
    faltas?: boolean | alumno$faltasArgs
    _count?: boolean | AlumnoCountOutputTypeArgs
  }


  export type alumnoInclude = {
    divisiones?: boolean | alumno$divisionesArgs
    notas?: boolean | alumno$notasArgs
    faltas?: boolean | alumno$faltasArgs
    _count?: boolean | AlumnoCountOutputTypeArgs
  }

  export type alumnoGetPayload<S extends boolean | null | undefined | alumnoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? alumno :
    S extends undefined ? never :
    S extends { include: any } & (alumnoArgs | alumnoFindManyArgs)
    ? alumno  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'divisiones' ? Array < divison_de_alumnoGetPayload<S['include'][P]>>  :
        P extends 'notas' ? Array < notasGetPayload<S['include'][P]>>  :
        P extends 'faltas' ? Array < faltasGetPayload<S['include'][P]>>  :
        P extends '_count' ? AlumnoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (alumnoArgs | alumnoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'divisiones' ? Array < divison_de_alumnoGetPayload<S['select'][P]>>  :
        P extends 'notas' ? Array < notasGetPayload<S['select'][P]>>  :
        P extends 'faltas' ? Array < faltasGetPayload<S['select'][P]>>  :
        P extends '_count' ? AlumnoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof alumno ? alumno[P] : never
  } 
      : alumno


  type alumnoCountArgs = 
    Omit<alumnoFindManyArgs, 'select' | 'include'> & {
      select?: AlumnoCountAggregateInputType | true
    }

  export interface alumnoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Alumno that matches the filter.
     * @param {alumnoFindUniqueArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends alumnoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, alumnoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'alumno'> extends True ? Prisma__alumnoClient<alumnoGetPayload<T>> : Prisma__alumnoClient<alumnoGetPayload<T> | null, null>

    /**
     * Find one Alumno that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {alumnoFindUniqueOrThrowArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends alumnoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, alumnoFindUniqueOrThrowArgs>
    ): Prisma__alumnoClient<alumnoGetPayload<T>>

    /**
     * Find the first Alumno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoFindFirstArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends alumnoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, alumnoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'alumno'> extends True ? Prisma__alumnoClient<alumnoGetPayload<T>> : Prisma__alumnoClient<alumnoGetPayload<T> | null, null>

    /**
     * Find the first Alumno that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoFindFirstOrThrowArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends alumnoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, alumnoFindFirstOrThrowArgs>
    ): Prisma__alumnoClient<alumnoGetPayload<T>>

    /**
     * Find zero or more Alumnos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alumnos
     * const alumnos = await prisma.alumno.findMany()
     * 
     * // Get first 10 Alumnos
     * const alumnos = await prisma.alumno.findMany({ take: 10 })
     * 
     * // Only select the `Dni_Alumno`
     * const alumnoWithDni_AlumnoOnly = await prisma.alumno.findMany({ select: { Dni_Alumno: true } })
     * 
    **/
    findMany<T extends alumnoFindManyArgs>(
      args?: SelectSubset<T, alumnoFindManyArgs>
    ): Prisma.PrismaPromise<Array<alumnoGetPayload<T>>>

    /**
     * Create a Alumno.
     * @param {alumnoCreateArgs} args - Arguments to create a Alumno.
     * @example
     * // Create one Alumno
     * const Alumno = await prisma.alumno.create({
     *   data: {
     *     // ... data to create a Alumno
     *   }
     * })
     * 
    **/
    create<T extends alumnoCreateArgs>(
      args: SelectSubset<T, alumnoCreateArgs>
    ): Prisma__alumnoClient<alumnoGetPayload<T>>

    /**
     * Create many Alumnos.
     *     @param {alumnoCreateManyArgs} args - Arguments to create many Alumnos.
     *     @example
     *     // Create many Alumnos
     *     const alumno = await prisma.alumno.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends alumnoCreateManyArgs>(
      args?: SelectSubset<T, alumnoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alumno.
     * @param {alumnoDeleteArgs} args - Arguments to delete one Alumno.
     * @example
     * // Delete one Alumno
     * const Alumno = await prisma.alumno.delete({
     *   where: {
     *     // ... filter to delete one Alumno
     *   }
     * })
     * 
    **/
    delete<T extends alumnoDeleteArgs>(
      args: SelectSubset<T, alumnoDeleteArgs>
    ): Prisma__alumnoClient<alumnoGetPayload<T>>

    /**
     * Update one Alumno.
     * @param {alumnoUpdateArgs} args - Arguments to update one Alumno.
     * @example
     * // Update one Alumno
     * const alumno = await prisma.alumno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends alumnoUpdateArgs>(
      args: SelectSubset<T, alumnoUpdateArgs>
    ): Prisma__alumnoClient<alumnoGetPayload<T>>

    /**
     * Delete zero or more Alumnos.
     * @param {alumnoDeleteManyArgs} args - Arguments to filter Alumnos to delete.
     * @example
     * // Delete a few Alumnos
     * const { count } = await prisma.alumno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends alumnoDeleteManyArgs>(
      args?: SelectSubset<T, alumnoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alumnos
     * const alumno = await prisma.alumno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends alumnoUpdateManyArgs>(
      args: SelectSubset<T, alumnoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alumno.
     * @param {alumnoUpsertArgs} args - Arguments to update or create a Alumno.
     * @example
     * // Update or create a Alumno
     * const alumno = await prisma.alumno.upsert({
     *   create: {
     *     // ... data to create a Alumno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alumno we want to update
     *   }
     * })
    **/
    upsert<T extends alumnoUpsertArgs>(
      args: SelectSubset<T, alumnoUpsertArgs>
    ): Prisma__alumnoClient<alumnoGetPayload<T>>

    /**
     * Count the number of Alumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoCountArgs} args - Arguments to filter Alumnos to count.
     * @example
     * // Count the number of Alumnos
     * const count = await prisma.alumno.count({
     *   where: {
     *     // ... the filter for the Alumnos we want to count
     *   }
     * })
    **/
    count<T extends alumnoCountArgs>(
      args?: Subset<T, alumnoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlumnoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlumnoAggregateArgs>(args: Subset<T, AlumnoAggregateArgs>): Prisma.PrismaPromise<GetAlumnoAggregateType<T>>

    /**
     * Group by Alumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlumnoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlumnoGroupByArgs['orderBy'] }
        : { orderBy?: AlumnoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlumnoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlumnoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for alumno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__alumnoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    divisiones<T extends alumno$divisionesArgs= {}>(args?: Subset<T, alumno$divisionesArgs>): Prisma.PrismaPromise<Array<divison_de_alumnoGetPayload<T>>| Null>;

    notas<T extends alumno$notasArgs= {}>(args?: Subset<T, alumno$notasArgs>): Prisma.PrismaPromise<Array<notasGetPayload<T>>| Null>;

    faltas<T extends alumno$faltasArgs= {}>(args?: Subset<T, alumno$faltasArgs>): Prisma.PrismaPromise<Array<faltasGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * alumno base type for findUnique actions
   */
  export type alumnoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alumnoInclude | null
    /**
     * Filter, which alumno to fetch.
     */
    where: alumnoWhereUniqueInput
  }

  /**
   * alumno findUnique
   */
  export interface alumnoFindUniqueArgs extends alumnoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * alumno findUniqueOrThrow
   */
  export type alumnoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alumnoInclude | null
    /**
     * Filter, which alumno to fetch.
     */
    where: alumnoWhereUniqueInput
  }


  /**
   * alumno base type for findFirst actions
   */
  export type alumnoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alumnoInclude | null
    /**
     * Filter, which alumno to fetch.
     */
    where?: alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumnos to fetch.
     */
    orderBy?: Enumerable<alumnoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alumnos.
     */
    cursor?: alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alumnos.
     */
    distinct?: Enumerable<AlumnoScalarFieldEnum>
  }

  /**
   * alumno findFirst
   */
  export interface alumnoFindFirstArgs extends alumnoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * alumno findFirstOrThrow
   */
  export type alumnoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alumnoInclude | null
    /**
     * Filter, which alumno to fetch.
     */
    where?: alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumnos to fetch.
     */
    orderBy?: Enumerable<alumnoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alumnos.
     */
    cursor?: alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alumnos.
     */
    distinct?: Enumerable<AlumnoScalarFieldEnum>
  }


  /**
   * alumno findMany
   */
  export type alumnoFindManyArgs = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alumnoInclude | null
    /**
     * Filter, which alumnos to fetch.
     */
    where?: alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumnos to fetch.
     */
    orderBy?: Enumerable<alumnoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alumnos.
     */
    cursor?: alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumnos.
     */
    skip?: number
    distinct?: Enumerable<AlumnoScalarFieldEnum>
  }


  /**
   * alumno create
   */
  export type alumnoCreateArgs = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alumnoInclude | null
    /**
     * The data needed to create a alumno.
     */
    data: XOR<alumnoCreateInput, alumnoUncheckedCreateInput>
  }


  /**
   * alumno createMany
   */
  export type alumnoCreateManyArgs = {
    /**
     * The data used to create many alumnos.
     */
    data: Enumerable<alumnoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * alumno update
   */
  export type alumnoUpdateArgs = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alumnoInclude | null
    /**
     * The data needed to update a alumno.
     */
    data: XOR<alumnoUpdateInput, alumnoUncheckedUpdateInput>
    /**
     * Choose, which alumno to update.
     */
    where: alumnoWhereUniqueInput
  }


  /**
   * alumno updateMany
   */
  export type alumnoUpdateManyArgs = {
    /**
     * The data used to update alumnos.
     */
    data: XOR<alumnoUpdateManyMutationInput, alumnoUncheckedUpdateManyInput>
    /**
     * Filter which alumnos to update
     */
    where?: alumnoWhereInput
  }


  /**
   * alumno upsert
   */
  export type alumnoUpsertArgs = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alumnoInclude | null
    /**
     * The filter to search for the alumno to update in case it exists.
     */
    where: alumnoWhereUniqueInput
    /**
     * In case the alumno found by the `where` argument doesn't exist, create a new alumno with this data.
     */
    create: XOR<alumnoCreateInput, alumnoUncheckedCreateInput>
    /**
     * In case the alumno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alumnoUpdateInput, alumnoUncheckedUpdateInput>
  }


  /**
   * alumno delete
   */
  export type alumnoDeleteArgs = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alumnoInclude | null
    /**
     * Filter which alumno to delete.
     */
    where: alumnoWhereUniqueInput
  }


  /**
   * alumno deleteMany
   */
  export type alumnoDeleteManyArgs = {
    /**
     * Filter which alumnos to delete
     */
    where?: alumnoWhereInput
  }


  /**
   * alumno.divisiones
   */
  export type alumno$divisionesArgs = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
    where?: divison_de_alumnoWhereInput
    orderBy?: Enumerable<divison_de_alumnoOrderByWithRelationInput>
    cursor?: divison_de_alumnoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Divison_de_alumnoScalarFieldEnum>
  }


  /**
   * alumno.notas
   */
  export type alumno$notasArgs = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
    where?: notasWhereInput
    orderBy?: Enumerable<notasOrderByWithRelationInput>
    cursor?: notasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NotasScalarFieldEnum>
  }


  /**
   * alumno.faltas
   */
  export type alumno$faltasArgs = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
    where?: faltasWhereInput
    orderBy?: Enumerable<faltasOrderByWithRelationInput>
    cursor?: faltasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FaltasScalarFieldEnum>
  }


  /**
   * alumno without action
   */
  export type alumnoArgs = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alumnoInclude | null
  }



  /**
   * Model Clase
   */


  export type AggregateClase = {
    _count: ClaseCountAggregateOutputType | null
    _avg: ClaseAvgAggregateOutputType | null
    _sum: ClaseSumAggregateOutputType | null
    _min: ClaseMinAggregateOutputType | null
    _max: ClaseMaxAggregateOutputType | null
  }

  export type ClaseAvgAggregateOutputType = {
    Clase_ID: number | null
    Division_ID: number | null
    Materia_ID: number | null
    Profesor_ID: number | null
  }

  export type ClaseSumAggregateOutputType = {
    Clase_ID: number | null
    Division_ID: number | null
    Materia_ID: number | null
    Profesor_ID: number | null
  }

  export type ClaseMinAggregateOutputType = {
    Clase_ID: number | null
    Division_ID: number | null
    Materia_ID: number | null
    Profesor_ID: number | null
    Fecha_Comienzo: Date | null
    Fecha_Final: Date | null
  }

  export type ClaseMaxAggregateOutputType = {
    Clase_ID: number | null
    Division_ID: number | null
    Materia_ID: number | null
    Profesor_ID: number | null
    Fecha_Comienzo: Date | null
    Fecha_Final: Date | null
  }

  export type ClaseCountAggregateOutputType = {
    Clase_ID: number
    Division_ID: number
    Materia_ID: number
    Profesor_ID: number
    Fecha_Comienzo: number
    Fecha_Final: number
    _all: number
  }


  export type ClaseAvgAggregateInputType = {
    Clase_ID?: true
    Division_ID?: true
    Materia_ID?: true
    Profesor_ID?: true
  }

  export type ClaseSumAggregateInputType = {
    Clase_ID?: true
    Division_ID?: true
    Materia_ID?: true
    Profesor_ID?: true
  }

  export type ClaseMinAggregateInputType = {
    Clase_ID?: true
    Division_ID?: true
    Materia_ID?: true
    Profesor_ID?: true
    Fecha_Comienzo?: true
    Fecha_Final?: true
  }

  export type ClaseMaxAggregateInputType = {
    Clase_ID?: true
    Division_ID?: true
    Materia_ID?: true
    Profesor_ID?: true
    Fecha_Comienzo?: true
    Fecha_Final?: true
  }

  export type ClaseCountAggregateInputType = {
    Clase_ID?: true
    Division_ID?: true
    Materia_ID?: true
    Profesor_ID?: true
    Fecha_Comienzo?: true
    Fecha_Final?: true
    _all?: true
  }

  export type ClaseAggregateArgs = {
    /**
     * Filter which Clase to aggregate.
     */
    where?: ClaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clases to fetch.
     */
    orderBy?: Enumerable<ClaseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clases
    **/
    _count?: true | ClaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaseMaxAggregateInputType
  }

  export type GetClaseAggregateType<T extends ClaseAggregateArgs> = {
        [P in keyof T & keyof AggregateClase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClase[P]>
      : GetScalarType<T[P], AggregateClase[P]>
  }




  export type ClaseGroupByArgs = {
    where?: ClaseWhereInput
    orderBy?: Enumerable<ClaseOrderByWithAggregationInput>
    by: ClaseScalarFieldEnum[]
    having?: ClaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaseCountAggregateInputType | true
    _avg?: ClaseAvgAggregateInputType
    _sum?: ClaseSumAggregateInputType
    _min?: ClaseMinAggregateInputType
    _max?: ClaseMaxAggregateInputType
  }


  export type ClaseGroupByOutputType = {
    Clase_ID: number
    Division_ID: number
    Materia_ID: number
    Profesor_ID: number
    Fecha_Comienzo: Date | null
    Fecha_Final: Date | null
    _count: ClaseCountAggregateOutputType | null
    _avg: ClaseAvgAggregateOutputType | null
    _sum: ClaseSumAggregateOutputType | null
    _min: ClaseMinAggregateOutputType | null
    _max: ClaseMaxAggregateOutputType | null
  }

  type GetClaseGroupByPayload<T extends ClaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ClaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaseGroupByOutputType[P]>
            : GetScalarType<T[P], ClaseGroupByOutputType[P]>
        }
      >
    >


  export type ClaseSelect = {
    Clase_ID?: boolean
    Division_ID?: boolean
    Materia_ID?: boolean
    Profesor_ID?: boolean
    Fecha_Comienzo?: boolean
    Fecha_Final?: boolean
    Division?: boolean | divisionArgs
    Materia?: boolean | materiaArgs
    Profesor?: boolean | profesorArgs
  }


  export type ClaseInclude = {
    Division?: boolean | divisionArgs
    Materia?: boolean | materiaArgs
    Profesor?: boolean | profesorArgs
  }

  export type ClaseGetPayload<S extends boolean | null | undefined | ClaseArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Clase :
    S extends undefined ? never :
    S extends { include: any } & (ClaseArgs | ClaseFindManyArgs)
    ? Clase  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Division' ? divisionGetPayload<S['include'][P]> | null :
        P extends 'Materia' ? materiaGetPayload<S['include'][P]> | null :
        P extends 'Profesor' ? profesorGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (ClaseArgs | ClaseFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Division' ? divisionGetPayload<S['select'][P]> | null :
        P extends 'Materia' ? materiaGetPayload<S['select'][P]> | null :
        P extends 'Profesor' ? profesorGetPayload<S['select'][P]> | null :  P extends keyof Clase ? Clase[P] : never
  } 
      : Clase


  type ClaseCountArgs = 
    Omit<ClaseFindManyArgs, 'select' | 'include'> & {
      select?: ClaseCountAggregateInputType | true
    }

  export interface ClaseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Clase that matches the filter.
     * @param {ClaseFindUniqueArgs} args - Arguments to find a Clase
     * @example
     * // Get one Clase
     * const clase = await prisma.clase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClaseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClaseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Clase'> extends True ? Prisma__ClaseClient<ClaseGetPayload<T>> : Prisma__ClaseClient<ClaseGetPayload<T> | null, null>

    /**
     * Find one Clase that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClaseFindUniqueOrThrowArgs} args - Arguments to find a Clase
     * @example
     * // Get one Clase
     * const clase = await prisma.clase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClaseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClaseFindUniqueOrThrowArgs>
    ): Prisma__ClaseClient<ClaseGetPayload<T>>

    /**
     * Find the first Clase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseFindFirstArgs} args - Arguments to find a Clase
     * @example
     * // Get one Clase
     * const clase = await prisma.clase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClaseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClaseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Clase'> extends True ? Prisma__ClaseClient<ClaseGetPayload<T>> : Prisma__ClaseClient<ClaseGetPayload<T> | null, null>

    /**
     * Find the first Clase that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseFindFirstOrThrowArgs} args - Arguments to find a Clase
     * @example
     * // Get one Clase
     * const clase = await prisma.clase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClaseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClaseFindFirstOrThrowArgs>
    ): Prisma__ClaseClient<ClaseGetPayload<T>>

    /**
     * Find zero or more Clases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clases
     * const clases = await prisma.clase.findMany()
     * 
     * // Get first 10 Clases
     * const clases = await prisma.clase.findMany({ take: 10 })
     * 
     * // Only select the `Clase_ID`
     * const claseWithClase_IDOnly = await prisma.clase.findMany({ select: { Clase_ID: true } })
     * 
    **/
    findMany<T extends ClaseFindManyArgs>(
      args?: SelectSubset<T, ClaseFindManyArgs>
    ): Prisma.PrismaPromise<Array<ClaseGetPayload<T>>>

    /**
     * Create a Clase.
     * @param {ClaseCreateArgs} args - Arguments to create a Clase.
     * @example
     * // Create one Clase
     * const Clase = await prisma.clase.create({
     *   data: {
     *     // ... data to create a Clase
     *   }
     * })
     * 
    **/
    create<T extends ClaseCreateArgs>(
      args: SelectSubset<T, ClaseCreateArgs>
    ): Prisma__ClaseClient<ClaseGetPayload<T>>

    /**
     * Create many Clases.
     *     @param {ClaseCreateManyArgs} args - Arguments to create many Clases.
     *     @example
     *     // Create many Clases
     *     const clase = await prisma.clase.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClaseCreateManyArgs>(
      args?: SelectSubset<T, ClaseCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clase.
     * @param {ClaseDeleteArgs} args - Arguments to delete one Clase.
     * @example
     * // Delete one Clase
     * const Clase = await prisma.clase.delete({
     *   where: {
     *     // ... filter to delete one Clase
     *   }
     * })
     * 
    **/
    delete<T extends ClaseDeleteArgs>(
      args: SelectSubset<T, ClaseDeleteArgs>
    ): Prisma__ClaseClient<ClaseGetPayload<T>>

    /**
     * Update one Clase.
     * @param {ClaseUpdateArgs} args - Arguments to update one Clase.
     * @example
     * // Update one Clase
     * const clase = await prisma.clase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClaseUpdateArgs>(
      args: SelectSubset<T, ClaseUpdateArgs>
    ): Prisma__ClaseClient<ClaseGetPayload<T>>

    /**
     * Delete zero or more Clases.
     * @param {ClaseDeleteManyArgs} args - Arguments to filter Clases to delete.
     * @example
     * // Delete a few Clases
     * const { count } = await prisma.clase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClaseDeleteManyArgs>(
      args?: SelectSubset<T, ClaseDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clases
     * const clase = await prisma.clase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClaseUpdateManyArgs>(
      args: SelectSubset<T, ClaseUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clase.
     * @param {ClaseUpsertArgs} args - Arguments to update or create a Clase.
     * @example
     * // Update or create a Clase
     * const clase = await prisma.clase.upsert({
     *   create: {
     *     // ... data to create a Clase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clase we want to update
     *   }
     * })
    **/
    upsert<T extends ClaseUpsertArgs>(
      args: SelectSubset<T, ClaseUpsertArgs>
    ): Prisma__ClaseClient<ClaseGetPayload<T>>

    /**
     * Count the number of Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseCountArgs} args - Arguments to filter Clases to count.
     * @example
     * // Count the number of Clases
     * const count = await prisma.clase.count({
     *   where: {
     *     // ... the filter for the Clases we want to count
     *   }
     * })
    **/
    count<T extends ClaseCountArgs>(
      args?: Subset<T, ClaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaseAggregateArgs>(args: Subset<T, ClaseAggregateArgs>): Prisma.PrismaPromise<GetClaseAggregateType<T>>

    /**
     * Group by Clase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaseGroupByArgs['orderBy'] }
        : { orderBy?: ClaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Clase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClaseClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Division<T extends divisionArgs= {}>(args?: Subset<T, divisionArgs>): Prisma__divisionClient<divisionGetPayload<T> | Null>;

    Materia<T extends materiaArgs= {}>(args?: Subset<T, materiaArgs>): Prisma__materiaClient<materiaGetPayload<T> | Null>;

    Profesor<T extends profesorArgs= {}>(args?: Subset<T, profesorArgs>): Prisma__profesorClient<profesorGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Clase base type for findUnique actions
   */
  export type ClaseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    /**
     * Filter, which Clase to fetch.
     */
    where: ClaseWhereUniqueInput
  }

  /**
   * Clase findUnique
   */
  export interface ClaseFindUniqueArgs extends ClaseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Clase findUniqueOrThrow
   */
  export type ClaseFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    /**
     * Filter, which Clase to fetch.
     */
    where: ClaseWhereUniqueInput
  }


  /**
   * Clase base type for findFirst actions
   */
  export type ClaseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    /**
     * Filter, which Clase to fetch.
     */
    where?: ClaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clases to fetch.
     */
    orderBy?: Enumerable<ClaseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clases.
     */
    cursor?: ClaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clases.
     */
    distinct?: Enumerable<ClaseScalarFieldEnum>
  }

  /**
   * Clase findFirst
   */
  export interface ClaseFindFirstArgs extends ClaseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Clase findFirstOrThrow
   */
  export type ClaseFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    /**
     * Filter, which Clase to fetch.
     */
    where?: ClaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clases to fetch.
     */
    orderBy?: Enumerable<ClaseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clases.
     */
    cursor?: ClaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clases.
     */
    distinct?: Enumerable<ClaseScalarFieldEnum>
  }


  /**
   * Clase findMany
   */
  export type ClaseFindManyArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    /**
     * Filter, which Clases to fetch.
     */
    where?: ClaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clases to fetch.
     */
    orderBy?: Enumerable<ClaseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clases.
     */
    cursor?: ClaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clases.
     */
    skip?: number
    distinct?: Enumerable<ClaseScalarFieldEnum>
  }


  /**
   * Clase create
   */
  export type ClaseCreateArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    /**
     * The data needed to create a Clase.
     */
    data: XOR<ClaseCreateInput, ClaseUncheckedCreateInput>
  }


  /**
   * Clase createMany
   */
  export type ClaseCreateManyArgs = {
    /**
     * The data used to create many Clases.
     */
    data: Enumerable<ClaseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Clase update
   */
  export type ClaseUpdateArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    /**
     * The data needed to update a Clase.
     */
    data: XOR<ClaseUpdateInput, ClaseUncheckedUpdateInput>
    /**
     * Choose, which Clase to update.
     */
    where: ClaseWhereUniqueInput
  }


  /**
   * Clase updateMany
   */
  export type ClaseUpdateManyArgs = {
    /**
     * The data used to update Clases.
     */
    data: XOR<ClaseUpdateManyMutationInput, ClaseUncheckedUpdateManyInput>
    /**
     * Filter which Clases to update
     */
    where?: ClaseWhereInput
  }


  /**
   * Clase upsert
   */
  export type ClaseUpsertArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    /**
     * The filter to search for the Clase to update in case it exists.
     */
    where: ClaseWhereUniqueInput
    /**
     * In case the Clase found by the `where` argument doesn't exist, create a new Clase with this data.
     */
    create: XOR<ClaseCreateInput, ClaseUncheckedCreateInput>
    /**
     * In case the Clase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaseUpdateInput, ClaseUncheckedUpdateInput>
  }


  /**
   * Clase delete
   */
  export type ClaseDeleteArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    /**
     * Filter which Clase to delete.
     */
    where: ClaseWhereUniqueInput
  }


  /**
   * Clase deleteMany
   */
  export type ClaseDeleteManyArgs = {
    /**
     * Filter which Clases to delete
     */
    where?: ClaseWhereInput
  }


  /**
   * Clase without action
   */
  export type ClaseArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
  }



  /**
   * Model division
   */


  export type AggregateDivision = {
    _count: DivisionCountAggregateOutputType | null
    _avg: DivisionAvgAggregateOutputType | null
    _sum: DivisionSumAggregateOutputType | null
    _min: DivisionMinAggregateOutputType | null
    _max: DivisionMaxAggregateOutputType | null
  }

  export type DivisionAvgAggregateOutputType = {
    Division_ID: number | null
    Division_Escolar: number | null
  }

  export type DivisionSumAggregateOutputType = {
    Division_ID: number | null
    Division_Escolar: number | null
  }

  export type DivisionMinAggregateOutputType = {
    Division_ID: number | null
    Ano_Escolar: string | null
    Division_Escolar: number | null
    Turno: string | null
  }

  export type DivisionMaxAggregateOutputType = {
    Division_ID: number | null
    Ano_Escolar: string | null
    Division_Escolar: number | null
    Turno: string | null
  }

  export type DivisionCountAggregateOutputType = {
    Division_ID: number
    Ano_Escolar: number
    Division_Escolar: number
    Turno: number
    _all: number
  }


  export type DivisionAvgAggregateInputType = {
    Division_ID?: true
    Division_Escolar?: true
  }

  export type DivisionSumAggregateInputType = {
    Division_ID?: true
    Division_Escolar?: true
  }

  export type DivisionMinAggregateInputType = {
    Division_ID?: true
    Ano_Escolar?: true
    Division_Escolar?: true
    Turno?: true
  }

  export type DivisionMaxAggregateInputType = {
    Division_ID?: true
    Ano_Escolar?: true
    Division_Escolar?: true
    Turno?: true
  }

  export type DivisionCountAggregateInputType = {
    Division_ID?: true
    Ano_Escolar?: true
    Division_Escolar?: true
    Turno?: true
    _all?: true
  }

  export type DivisionAggregateArgs = {
    /**
     * Filter which division to aggregate.
     */
    where?: divisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisions to fetch.
     */
    orderBy?: Enumerable<divisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: divisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned divisions
    **/
    _count?: true | DivisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DivisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DivisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DivisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DivisionMaxAggregateInputType
  }

  export type GetDivisionAggregateType<T extends DivisionAggregateArgs> = {
        [P in keyof T & keyof AggregateDivision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDivision[P]>
      : GetScalarType<T[P], AggregateDivision[P]>
  }




  export type DivisionGroupByArgs = {
    where?: divisionWhereInput
    orderBy?: Enumerable<divisionOrderByWithAggregationInput>
    by: DivisionScalarFieldEnum[]
    having?: divisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DivisionCountAggregateInputType | true
    _avg?: DivisionAvgAggregateInputType
    _sum?: DivisionSumAggregateInputType
    _min?: DivisionMinAggregateInputType
    _max?: DivisionMaxAggregateInputType
  }


  export type DivisionGroupByOutputType = {
    Division_ID: number
    Ano_Escolar: string
    Division_Escolar: number
    Turno: string
    _count: DivisionCountAggregateOutputType | null
    _avg: DivisionAvgAggregateOutputType | null
    _sum: DivisionSumAggregateOutputType | null
    _min: DivisionMinAggregateOutputType | null
    _max: DivisionMaxAggregateOutputType | null
  }

  type GetDivisionGroupByPayload<T extends DivisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DivisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DivisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DivisionGroupByOutputType[P]>
            : GetScalarType<T[P], DivisionGroupByOutputType[P]>
        }
      >
    >


  export type divisionSelect = {
    Division_ID?: boolean
    Ano_Escolar?: boolean
    Division_Escolar?: boolean
    Turno?: boolean
    Materias?: boolean | division$MateriasArgs
    _count?: boolean | DivisionCountOutputTypeArgs
  }


  export type divisionInclude = {
    Materias?: boolean | division$MateriasArgs
    _count?: boolean | DivisionCountOutputTypeArgs
  }

  export type divisionGetPayload<S extends boolean | null | undefined | divisionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? division :
    S extends undefined ? never :
    S extends { include: any } & (divisionArgs | divisionFindManyArgs)
    ? division  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Materias' ? Array < ClaseGetPayload<S['include'][P]>>  :
        P extends '_count' ? DivisionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (divisionArgs | divisionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Materias' ? Array < ClaseGetPayload<S['select'][P]>>  :
        P extends '_count' ? DivisionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof division ? division[P] : never
  } 
      : division


  type divisionCountArgs = 
    Omit<divisionFindManyArgs, 'select' | 'include'> & {
      select?: DivisionCountAggregateInputType | true
    }

  export interface divisionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Division that matches the filter.
     * @param {divisionFindUniqueArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends divisionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, divisionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'division'> extends True ? Prisma__divisionClient<divisionGetPayload<T>> : Prisma__divisionClient<divisionGetPayload<T> | null, null>

    /**
     * Find one Division that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {divisionFindUniqueOrThrowArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends divisionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, divisionFindUniqueOrThrowArgs>
    ): Prisma__divisionClient<divisionGetPayload<T>>

    /**
     * Find the first Division that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionFindFirstArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends divisionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, divisionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'division'> extends True ? Prisma__divisionClient<divisionGetPayload<T>> : Prisma__divisionClient<divisionGetPayload<T> | null, null>

    /**
     * Find the first Division that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionFindFirstOrThrowArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends divisionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, divisionFindFirstOrThrowArgs>
    ): Prisma__divisionClient<divisionGetPayload<T>>

    /**
     * Find zero or more Divisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Divisions
     * const divisions = await prisma.division.findMany()
     * 
     * // Get first 10 Divisions
     * const divisions = await prisma.division.findMany({ take: 10 })
     * 
     * // Only select the `Division_ID`
     * const divisionWithDivision_IDOnly = await prisma.division.findMany({ select: { Division_ID: true } })
     * 
    **/
    findMany<T extends divisionFindManyArgs>(
      args?: SelectSubset<T, divisionFindManyArgs>
    ): Prisma.PrismaPromise<Array<divisionGetPayload<T>>>

    /**
     * Create a Division.
     * @param {divisionCreateArgs} args - Arguments to create a Division.
     * @example
     * // Create one Division
     * const Division = await prisma.division.create({
     *   data: {
     *     // ... data to create a Division
     *   }
     * })
     * 
    **/
    create<T extends divisionCreateArgs>(
      args: SelectSubset<T, divisionCreateArgs>
    ): Prisma__divisionClient<divisionGetPayload<T>>

    /**
     * Create many Divisions.
     *     @param {divisionCreateManyArgs} args - Arguments to create many Divisions.
     *     @example
     *     // Create many Divisions
     *     const division = await prisma.division.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends divisionCreateManyArgs>(
      args?: SelectSubset<T, divisionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Division.
     * @param {divisionDeleteArgs} args - Arguments to delete one Division.
     * @example
     * // Delete one Division
     * const Division = await prisma.division.delete({
     *   where: {
     *     // ... filter to delete one Division
     *   }
     * })
     * 
    **/
    delete<T extends divisionDeleteArgs>(
      args: SelectSubset<T, divisionDeleteArgs>
    ): Prisma__divisionClient<divisionGetPayload<T>>

    /**
     * Update one Division.
     * @param {divisionUpdateArgs} args - Arguments to update one Division.
     * @example
     * // Update one Division
     * const division = await prisma.division.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends divisionUpdateArgs>(
      args: SelectSubset<T, divisionUpdateArgs>
    ): Prisma__divisionClient<divisionGetPayload<T>>

    /**
     * Delete zero or more Divisions.
     * @param {divisionDeleteManyArgs} args - Arguments to filter Divisions to delete.
     * @example
     * // Delete a few Divisions
     * const { count } = await prisma.division.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends divisionDeleteManyArgs>(
      args?: SelectSubset<T, divisionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Divisions
     * const division = await prisma.division.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends divisionUpdateManyArgs>(
      args: SelectSubset<T, divisionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Division.
     * @param {divisionUpsertArgs} args - Arguments to update or create a Division.
     * @example
     * // Update or create a Division
     * const division = await prisma.division.upsert({
     *   create: {
     *     // ... data to create a Division
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Division we want to update
     *   }
     * })
    **/
    upsert<T extends divisionUpsertArgs>(
      args: SelectSubset<T, divisionUpsertArgs>
    ): Prisma__divisionClient<divisionGetPayload<T>>

    /**
     * Count the number of Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionCountArgs} args - Arguments to filter Divisions to count.
     * @example
     * // Count the number of Divisions
     * const count = await prisma.division.count({
     *   where: {
     *     // ... the filter for the Divisions we want to count
     *   }
     * })
    **/
    count<T extends divisionCountArgs>(
      args?: Subset<T, divisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DivisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Division.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DivisionAggregateArgs>(args: Subset<T, DivisionAggregateArgs>): Prisma.PrismaPromise<GetDivisionAggregateType<T>>

    /**
     * Group by Division.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DivisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DivisionGroupByArgs['orderBy'] }
        : { orderBy?: DivisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DivisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDivisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for division.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__divisionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Materias<T extends division$MateriasArgs= {}>(args?: Subset<T, division$MateriasArgs>): Prisma.PrismaPromise<Array<ClaseGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * division base type for findUnique actions
   */
  export type divisionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the division
     */
    select?: divisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divisionInclude | null
    /**
     * Filter, which division to fetch.
     */
    where: divisionWhereUniqueInput
  }

  /**
   * division findUnique
   */
  export interface divisionFindUniqueArgs extends divisionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * division findUniqueOrThrow
   */
  export type divisionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the division
     */
    select?: divisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divisionInclude | null
    /**
     * Filter, which division to fetch.
     */
    where: divisionWhereUniqueInput
  }


  /**
   * division base type for findFirst actions
   */
  export type divisionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the division
     */
    select?: divisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divisionInclude | null
    /**
     * Filter, which division to fetch.
     */
    where?: divisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisions to fetch.
     */
    orderBy?: Enumerable<divisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for divisions.
     */
    cursor?: divisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of divisions.
     */
    distinct?: Enumerable<DivisionScalarFieldEnum>
  }

  /**
   * division findFirst
   */
  export interface divisionFindFirstArgs extends divisionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * division findFirstOrThrow
   */
  export type divisionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the division
     */
    select?: divisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divisionInclude | null
    /**
     * Filter, which division to fetch.
     */
    where?: divisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisions to fetch.
     */
    orderBy?: Enumerable<divisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for divisions.
     */
    cursor?: divisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of divisions.
     */
    distinct?: Enumerable<DivisionScalarFieldEnum>
  }


  /**
   * division findMany
   */
  export type divisionFindManyArgs = {
    /**
     * Select specific fields to fetch from the division
     */
    select?: divisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divisionInclude | null
    /**
     * Filter, which divisions to fetch.
     */
    where?: divisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisions to fetch.
     */
    orderBy?: Enumerable<divisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing divisions.
     */
    cursor?: divisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisions.
     */
    skip?: number
    distinct?: Enumerable<DivisionScalarFieldEnum>
  }


  /**
   * division create
   */
  export type divisionCreateArgs = {
    /**
     * Select specific fields to fetch from the division
     */
    select?: divisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divisionInclude | null
    /**
     * The data needed to create a division.
     */
    data: XOR<divisionCreateInput, divisionUncheckedCreateInput>
  }


  /**
   * division createMany
   */
  export type divisionCreateManyArgs = {
    /**
     * The data used to create many divisions.
     */
    data: Enumerable<divisionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * division update
   */
  export type divisionUpdateArgs = {
    /**
     * Select specific fields to fetch from the division
     */
    select?: divisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divisionInclude | null
    /**
     * The data needed to update a division.
     */
    data: XOR<divisionUpdateInput, divisionUncheckedUpdateInput>
    /**
     * Choose, which division to update.
     */
    where: divisionWhereUniqueInput
  }


  /**
   * division updateMany
   */
  export type divisionUpdateManyArgs = {
    /**
     * The data used to update divisions.
     */
    data: XOR<divisionUpdateManyMutationInput, divisionUncheckedUpdateManyInput>
    /**
     * Filter which divisions to update
     */
    where?: divisionWhereInput
  }


  /**
   * division upsert
   */
  export type divisionUpsertArgs = {
    /**
     * Select specific fields to fetch from the division
     */
    select?: divisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divisionInclude | null
    /**
     * The filter to search for the division to update in case it exists.
     */
    where: divisionWhereUniqueInput
    /**
     * In case the division found by the `where` argument doesn't exist, create a new division with this data.
     */
    create: XOR<divisionCreateInput, divisionUncheckedCreateInput>
    /**
     * In case the division was found with the provided `where` argument, update it with this data.
     */
    update: XOR<divisionUpdateInput, divisionUncheckedUpdateInput>
  }


  /**
   * division delete
   */
  export type divisionDeleteArgs = {
    /**
     * Select specific fields to fetch from the division
     */
    select?: divisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divisionInclude | null
    /**
     * Filter which division to delete.
     */
    where: divisionWhereUniqueInput
  }


  /**
   * division deleteMany
   */
  export type divisionDeleteManyArgs = {
    /**
     * Filter which divisions to delete
     */
    where?: divisionWhereInput
  }


  /**
   * division.Materias
   */
  export type division$MateriasArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    where?: ClaseWhereInput
    orderBy?: Enumerable<ClaseOrderByWithRelationInput>
    cursor?: ClaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClaseScalarFieldEnum>
  }


  /**
   * division without action
   */
  export type divisionArgs = {
    /**
     * Select specific fields to fetch from the division
     */
    select?: divisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divisionInclude | null
  }



  /**
   * Model divison_de_alumno
   */


  export type AggregateDivison_de_alumno = {
    _count: Divison_de_alumnoCountAggregateOutputType | null
    _avg: Divison_de_alumnoAvgAggregateOutputType | null
    _sum: Divison_de_alumnoSumAggregateOutputType | null
    _min: Divison_de_alumnoMinAggregateOutputType | null
    _max: Divison_de_alumnoMaxAggregateOutputType | null
  }

  export type Divison_de_alumnoAvgAggregateOutputType = {
    DivisionDA_ID: number | null
    DNi_Alumno: number | null
    Division_ID: number | null
    Anio_Calendario: number | null
  }

  export type Divison_de_alumnoSumAggregateOutputType = {
    DivisionDA_ID: number | null
    DNi_Alumno: number | null
    Division_ID: number | null
    Anio_Calendario: number | null
  }

  export type Divison_de_alumnoMinAggregateOutputType = {
    DivisionDA_ID: number | null
    DNi_Alumno: number | null
    Division_ID: number | null
    Anio_Calendario: number | null
  }

  export type Divison_de_alumnoMaxAggregateOutputType = {
    DivisionDA_ID: number | null
    DNi_Alumno: number | null
    Division_ID: number | null
    Anio_Calendario: number | null
  }

  export type Divison_de_alumnoCountAggregateOutputType = {
    DivisionDA_ID: number
    DNi_Alumno: number
    Division_ID: number
    Anio_Calendario: number
    _all: number
  }


  export type Divison_de_alumnoAvgAggregateInputType = {
    DivisionDA_ID?: true
    DNi_Alumno?: true
    Division_ID?: true
    Anio_Calendario?: true
  }

  export type Divison_de_alumnoSumAggregateInputType = {
    DivisionDA_ID?: true
    DNi_Alumno?: true
    Division_ID?: true
    Anio_Calendario?: true
  }

  export type Divison_de_alumnoMinAggregateInputType = {
    DivisionDA_ID?: true
    DNi_Alumno?: true
    Division_ID?: true
    Anio_Calendario?: true
  }

  export type Divison_de_alumnoMaxAggregateInputType = {
    DivisionDA_ID?: true
    DNi_Alumno?: true
    Division_ID?: true
    Anio_Calendario?: true
  }

  export type Divison_de_alumnoCountAggregateInputType = {
    DivisionDA_ID?: true
    DNi_Alumno?: true
    Division_ID?: true
    Anio_Calendario?: true
    _all?: true
  }

  export type Divison_de_alumnoAggregateArgs = {
    /**
     * Filter which divison_de_alumno to aggregate.
     */
    where?: divison_de_alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divison_de_alumnos to fetch.
     */
    orderBy?: Enumerable<divison_de_alumnoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: divison_de_alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divison_de_alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divison_de_alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned divison_de_alumnos
    **/
    _count?: true | Divison_de_alumnoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Divison_de_alumnoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Divison_de_alumnoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Divison_de_alumnoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Divison_de_alumnoMaxAggregateInputType
  }

  export type GetDivison_de_alumnoAggregateType<T extends Divison_de_alumnoAggregateArgs> = {
        [P in keyof T & keyof AggregateDivison_de_alumno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDivison_de_alumno[P]>
      : GetScalarType<T[P], AggregateDivison_de_alumno[P]>
  }




  export type Divison_de_alumnoGroupByArgs = {
    where?: divison_de_alumnoWhereInput
    orderBy?: Enumerable<divison_de_alumnoOrderByWithAggregationInput>
    by: Divison_de_alumnoScalarFieldEnum[]
    having?: divison_de_alumnoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Divison_de_alumnoCountAggregateInputType | true
    _avg?: Divison_de_alumnoAvgAggregateInputType
    _sum?: Divison_de_alumnoSumAggregateInputType
    _min?: Divison_de_alumnoMinAggregateInputType
    _max?: Divison_de_alumnoMaxAggregateInputType
  }


  export type Divison_de_alumnoGroupByOutputType = {
    DivisionDA_ID: number
    DNi_Alumno: number | null
    Division_ID: number
    Anio_Calendario: number
    _count: Divison_de_alumnoCountAggregateOutputType | null
    _avg: Divison_de_alumnoAvgAggregateOutputType | null
    _sum: Divison_de_alumnoSumAggregateOutputType | null
    _min: Divison_de_alumnoMinAggregateOutputType | null
    _max: Divison_de_alumnoMaxAggregateOutputType | null
  }

  type GetDivison_de_alumnoGroupByPayload<T extends Divison_de_alumnoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Divison_de_alumnoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Divison_de_alumnoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Divison_de_alumnoGroupByOutputType[P]>
            : GetScalarType<T[P], Divison_de_alumnoGroupByOutputType[P]>
        }
      >
    >


  export type divison_de_alumnoSelect = {
    DivisionDA_ID?: boolean
    DNi_Alumno?: boolean
    Division_ID?: boolean
    Anio_Calendario?: boolean
    Alumno?: boolean | alumnoArgs
  }


  export type divison_de_alumnoInclude = {
    Alumno?: boolean | alumnoArgs
  }

  export type divison_de_alumnoGetPayload<S extends boolean | null | undefined | divison_de_alumnoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? divison_de_alumno :
    S extends undefined ? never :
    S extends { include: any } & (divison_de_alumnoArgs | divison_de_alumnoFindManyArgs)
    ? divison_de_alumno  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Alumno' ? alumnoGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (divison_de_alumnoArgs | divison_de_alumnoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Alumno' ? alumnoGetPayload<S['select'][P]> | null :  P extends keyof divison_de_alumno ? divison_de_alumno[P] : never
  } 
      : divison_de_alumno


  type divison_de_alumnoCountArgs = 
    Omit<divison_de_alumnoFindManyArgs, 'select' | 'include'> & {
      select?: Divison_de_alumnoCountAggregateInputType | true
    }

  export interface divison_de_alumnoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Divison_de_alumno that matches the filter.
     * @param {divison_de_alumnoFindUniqueArgs} args - Arguments to find a Divison_de_alumno
     * @example
     * // Get one Divison_de_alumno
     * const divison_de_alumno = await prisma.divison_de_alumno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends divison_de_alumnoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, divison_de_alumnoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'divison_de_alumno'> extends True ? Prisma__divison_de_alumnoClient<divison_de_alumnoGetPayload<T>> : Prisma__divison_de_alumnoClient<divison_de_alumnoGetPayload<T> | null, null>

    /**
     * Find one Divison_de_alumno that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {divison_de_alumnoFindUniqueOrThrowArgs} args - Arguments to find a Divison_de_alumno
     * @example
     * // Get one Divison_de_alumno
     * const divison_de_alumno = await prisma.divison_de_alumno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends divison_de_alumnoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, divison_de_alumnoFindUniqueOrThrowArgs>
    ): Prisma__divison_de_alumnoClient<divison_de_alumnoGetPayload<T>>

    /**
     * Find the first Divison_de_alumno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divison_de_alumnoFindFirstArgs} args - Arguments to find a Divison_de_alumno
     * @example
     * // Get one Divison_de_alumno
     * const divison_de_alumno = await prisma.divison_de_alumno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends divison_de_alumnoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, divison_de_alumnoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'divison_de_alumno'> extends True ? Prisma__divison_de_alumnoClient<divison_de_alumnoGetPayload<T>> : Prisma__divison_de_alumnoClient<divison_de_alumnoGetPayload<T> | null, null>

    /**
     * Find the first Divison_de_alumno that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divison_de_alumnoFindFirstOrThrowArgs} args - Arguments to find a Divison_de_alumno
     * @example
     * // Get one Divison_de_alumno
     * const divison_de_alumno = await prisma.divison_de_alumno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends divison_de_alumnoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, divison_de_alumnoFindFirstOrThrowArgs>
    ): Prisma__divison_de_alumnoClient<divison_de_alumnoGetPayload<T>>

    /**
     * Find zero or more Divison_de_alumnos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divison_de_alumnoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Divison_de_alumnos
     * const divison_de_alumnos = await prisma.divison_de_alumno.findMany()
     * 
     * // Get first 10 Divison_de_alumnos
     * const divison_de_alumnos = await prisma.divison_de_alumno.findMany({ take: 10 })
     * 
     * // Only select the `DivisionDA_ID`
     * const divison_de_alumnoWithDivisionDA_IDOnly = await prisma.divison_de_alumno.findMany({ select: { DivisionDA_ID: true } })
     * 
    **/
    findMany<T extends divison_de_alumnoFindManyArgs>(
      args?: SelectSubset<T, divison_de_alumnoFindManyArgs>
    ): Prisma.PrismaPromise<Array<divison_de_alumnoGetPayload<T>>>

    /**
     * Create a Divison_de_alumno.
     * @param {divison_de_alumnoCreateArgs} args - Arguments to create a Divison_de_alumno.
     * @example
     * // Create one Divison_de_alumno
     * const Divison_de_alumno = await prisma.divison_de_alumno.create({
     *   data: {
     *     // ... data to create a Divison_de_alumno
     *   }
     * })
     * 
    **/
    create<T extends divison_de_alumnoCreateArgs>(
      args: SelectSubset<T, divison_de_alumnoCreateArgs>
    ): Prisma__divison_de_alumnoClient<divison_de_alumnoGetPayload<T>>

    /**
     * Create many Divison_de_alumnos.
     *     @param {divison_de_alumnoCreateManyArgs} args - Arguments to create many Divison_de_alumnos.
     *     @example
     *     // Create many Divison_de_alumnos
     *     const divison_de_alumno = await prisma.divison_de_alumno.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends divison_de_alumnoCreateManyArgs>(
      args?: SelectSubset<T, divison_de_alumnoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Divison_de_alumno.
     * @param {divison_de_alumnoDeleteArgs} args - Arguments to delete one Divison_de_alumno.
     * @example
     * // Delete one Divison_de_alumno
     * const Divison_de_alumno = await prisma.divison_de_alumno.delete({
     *   where: {
     *     // ... filter to delete one Divison_de_alumno
     *   }
     * })
     * 
    **/
    delete<T extends divison_de_alumnoDeleteArgs>(
      args: SelectSubset<T, divison_de_alumnoDeleteArgs>
    ): Prisma__divison_de_alumnoClient<divison_de_alumnoGetPayload<T>>

    /**
     * Update one Divison_de_alumno.
     * @param {divison_de_alumnoUpdateArgs} args - Arguments to update one Divison_de_alumno.
     * @example
     * // Update one Divison_de_alumno
     * const divison_de_alumno = await prisma.divison_de_alumno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends divison_de_alumnoUpdateArgs>(
      args: SelectSubset<T, divison_de_alumnoUpdateArgs>
    ): Prisma__divison_de_alumnoClient<divison_de_alumnoGetPayload<T>>

    /**
     * Delete zero or more Divison_de_alumnos.
     * @param {divison_de_alumnoDeleteManyArgs} args - Arguments to filter Divison_de_alumnos to delete.
     * @example
     * // Delete a few Divison_de_alumnos
     * const { count } = await prisma.divison_de_alumno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends divison_de_alumnoDeleteManyArgs>(
      args?: SelectSubset<T, divison_de_alumnoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divison_de_alumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divison_de_alumnoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Divison_de_alumnos
     * const divison_de_alumno = await prisma.divison_de_alumno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends divison_de_alumnoUpdateManyArgs>(
      args: SelectSubset<T, divison_de_alumnoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Divison_de_alumno.
     * @param {divison_de_alumnoUpsertArgs} args - Arguments to update or create a Divison_de_alumno.
     * @example
     * // Update or create a Divison_de_alumno
     * const divison_de_alumno = await prisma.divison_de_alumno.upsert({
     *   create: {
     *     // ... data to create a Divison_de_alumno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Divison_de_alumno we want to update
     *   }
     * })
    **/
    upsert<T extends divison_de_alumnoUpsertArgs>(
      args: SelectSubset<T, divison_de_alumnoUpsertArgs>
    ): Prisma__divison_de_alumnoClient<divison_de_alumnoGetPayload<T>>

    /**
     * Count the number of Divison_de_alumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divison_de_alumnoCountArgs} args - Arguments to filter Divison_de_alumnos to count.
     * @example
     * // Count the number of Divison_de_alumnos
     * const count = await prisma.divison_de_alumno.count({
     *   where: {
     *     // ... the filter for the Divison_de_alumnos we want to count
     *   }
     * })
    **/
    count<T extends divison_de_alumnoCountArgs>(
      args?: Subset<T, divison_de_alumnoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Divison_de_alumnoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Divison_de_alumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Divison_de_alumnoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Divison_de_alumnoAggregateArgs>(args: Subset<T, Divison_de_alumnoAggregateArgs>): Prisma.PrismaPromise<GetDivison_de_alumnoAggregateType<T>>

    /**
     * Group by Divison_de_alumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Divison_de_alumnoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Divison_de_alumnoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Divison_de_alumnoGroupByArgs['orderBy'] }
        : { orderBy?: Divison_de_alumnoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Divison_de_alumnoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDivison_de_alumnoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for divison_de_alumno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__divison_de_alumnoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Alumno<T extends alumnoArgs= {}>(args?: Subset<T, alumnoArgs>): Prisma__alumnoClient<alumnoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * divison_de_alumno base type for findUnique actions
   */
  export type divison_de_alumnoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
    /**
     * Filter, which divison_de_alumno to fetch.
     */
    where: divison_de_alumnoWhereUniqueInput
  }

  /**
   * divison_de_alumno findUnique
   */
  export interface divison_de_alumnoFindUniqueArgs extends divison_de_alumnoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * divison_de_alumno findUniqueOrThrow
   */
  export type divison_de_alumnoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
    /**
     * Filter, which divison_de_alumno to fetch.
     */
    where: divison_de_alumnoWhereUniqueInput
  }


  /**
   * divison_de_alumno base type for findFirst actions
   */
  export type divison_de_alumnoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
    /**
     * Filter, which divison_de_alumno to fetch.
     */
    where?: divison_de_alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divison_de_alumnos to fetch.
     */
    orderBy?: Enumerable<divison_de_alumnoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for divison_de_alumnos.
     */
    cursor?: divison_de_alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divison_de_alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divison_de_alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of divison_de_alumnos.
     */
    distinct?: Enumerable<Divison_de_alumnoScalarFieldEnum>
  }

  /**
   * divison_de_alumno findFirst
   */
  export interface divison_de_alumnoFindFirstArgs extends divison_de_alumnoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * divison_de_alumno findFirstOrThrow
   */
  export type divison_de_alumnoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
    /**
     * Filter, which divison_de_alumno to fetch.
     */
    where?: divison_de_alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divison_de_alumnos to fetch.
     */
    orderBy?: Enumerable<divison_de_alumnoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for divison_de_alumnos.
     */
    cursor?: divison_de_alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divison_de_alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divison_de_alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of divison_de_alumnos.
     */
    distinct?: Enumerable<Divison_de_alumnoScalarFieldEnum>
  }


  /**
   * divison_de_alumno findMany
   */
  export type divison_de_alumnoFindManyArgs = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
    /**
     * Filter, which divison_de_alumnos to fetch.
     */
    where?: divison_de_alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divison_de_alumnos to fetch.
     */
    orderBy?: Enumerable<divison_de_alumnoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing divison_de_alumnos.
     */
    cursor?: divison_de_alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divison_de_alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divison_de_alumnos.
     */
    skip?: number
    distinct?: Enumerable<Divison_de_alumnoScalarFieldEnum>
  }


  /**
   * divison_de_alumno create
   */
  export type divison_de_alumnoCreateArgs = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
    /**
     * The data needed to create a divison_de_alumno.
     */
    data: XOR<divison_de_alumnoCreateInput, divison_de_alumnoUncheckedCreateInput>
  }


  /**
   * divison_de_alumno createMany
   */
  export type divison_de_alumnoCreateManyArgs = {
    /**
     * The data used to create many divison_de_alumnos.
     */
    data: Enumerable<divison_de_alumnoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * divison_de_alumno update
   */
  export type divison_de_alumnoUpdateArgs = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
    /**
     * The data needed to update a divison_de_alumno.
     */
    data: XOR<divison_de_alumnoUpdateInput, divison_de_alumnoUncheckedUpdateInput>
    /**
     * Choose, which divison_de_alumno to update.
     */
    where: divison_de_alumnoWhereUniqueInput
  }


  /**
   * divison_de_alumno updateMany
   */
  export type divison_de_alumnoUpdateManyArgs = {
    /**
     * The data used to update divison_de_alumnos.
     */
    data: XOR<divison_de_alumnoUpdateManyMutationInput, divison_de_alumnoUncheckedUpdateManyInput>
    /**
     * Filter which divison_de_alumnos to update
     */
    where?: divison_de_alumnoWhereInput
  }


  /**
   * divison_de_alumno upsert
   */
  export type divison_de_alumnoUpsertArgs = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
    /**
     * The filter to search for the divison_de_alumno to update in case it exists.
     */
    where: divison_de_alumnoWhereUniqueInput
    /**
     * In case the divison_de_alumno found by the `where` argument doesn't exist, create a new divison_de_alumno with this data.
     */
    create: XOR<divison_de_alumnoCreateInput, divison_de_alumnoUncheckedCreateInput>
    /**
     * In case the divison_de_alumno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<divison_de_alumnoUpdateInput, divison_de_alumnoUncheckedUpdateInput>
  }


  /**
   * divison_de_alumno delete
   */
  export type divison_de_alumnoDeleteArgs = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
    /**
     * Filter which divison_de_alumno to delete.
     */
    where: divison_de_alumnoWhereUniqueInput
  }


  /**
   * divison_de_alumno deleteMany
   */
  export type divison_de_alumnoDeleteManyArgs = {
    /**
     * Filter which divison_de_alumnos to delete
     */
    where?: divison_de_alumnoWhereInput
  }


  /**
   * divison_de_alumno without action
   */
  export type divison_de_alumnoArgs = {
    /**
     * Select specific fields to fetch from the divison_de_alumno
     */
    select?: divison_de_alumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: divison_de_alumnoInclude | null
  }



  /**
   * Model evaluaciones
   */


  export type AggregateEvaluaciones = {
    _count: EvaluacionesCountAggregateOutputType | null
    _avg: EvaluacionesAvgAggregateOutputType | null
    _sum: EvaluacionesSumAggregateOutputType | null
    _min: EvaluacionesMinAggregateOutputType | null
    _max: EvaluacionesMaxAggregateOutputType | null
  }

  export type EvaluacionesAvgAggregateOutputType = {
    Evaluacion_ID: number | null
    Clase_ID: number | null
  }

  export type EvaluacionesSumAggregateOutputType = {
    Evaluacion_ID: number | null
    Clase_ID: number | null
  }

  export type EvaluacionesMinAggregateOutputType = {
    Evaluacion_ID: number | null
    Clase_ID: number | null
    Fecha: Date | null
    Detalles: string | null
  }

  export type EvaluacionesMaxAggregateOutputType = {
    Evaluacion_ID: number | null
    Clase_ID: number | null
    Fecha: Date | null
    Detalles: string | null
  }

  export type EvaluacionesCountAggregateOutputType = {
    Evaluacion_ID: number
    Clase_ID: number
    Fecha: number
    Detalles: number
    _all: number
  }


  export type EvaluacionesAvgAggregateInputType = {
    Evaluacion_ID?: true
    Clase_ID?: true
  }

  export type EvaluacionesSumAggregateInputType = {
    Evaluacion_ID?: true
    Clase_ID?: true
  }

  export type EvaluacionesMinAggregateInputType = {
    Evaluacion_ID?: true
    Clase_ID?: true
    Fecha?: true
    Detalles?: true
  }

  export type EvaluacionesMaxAggregateInputType = {
    Evaluacion_ID?: true
    Clase_ID?: true
    Fecha?: true
    Detalles?: true
  }

  export type EvaluacionesCountAggregateInputType = {
    Evaluacion_ID?: true
    Clase_ID?: true
    Fecha?: true
    Detalles?: true
    _all?: true
  }

  export type EvaluacionesAggregateArgs = {
    /**
     * Filter which evaluaciones to aggregate.
     */
    where?: evaluacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evaluaciones to fetch.
     */
    orderBy?: Enumerable<evaluacionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: evaluacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evaluaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evaluaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned evaluaciones
    **/
    _count?: true | EvaluacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluacionesMaxAggregateInputType
  }

  export type GetEvaluacionesAggregateType<T extends EvaluacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluaciones[P]>
      : GetScalarType<T[P], AggregateEvaluaciones[P]>
  }




  export type EvaluacionesGroupByArgs = {
    where?: evaluacionesWhereInput
    orderBy?: Enumerable<evaluacionesOrderByWithAggregationInput>
    by: EvaluacionesScalarFieldEnum[]
    having?: evaluacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluacionesCountAggregateInputType | true
    _avg?: EvaluacionesAvgAggregateInputType
    _sum?: EvaluacionesSumAggregateInputType
    _min?: EvaluacionesMinAggregateInputType
    _max?: EvaluacionesMaxAggregateInputType
  }


  export type EvaluacionesGroupByOutputType = {
    Evaluacion_ID: number
    Clase_ID: number
    Fecha: Date | null
    Detalles: string
    _count: EvaluacionesCountAggregateOutputType | null
    _avg: EvaluacionesAvgAggregateOutputType | null
    _sum: EvaluacionesSumAggregateOutputType | null
    _min: EvaluacionesMinAggregateOutputType | null
    _max: EvaluacionesMaxAggregateOutputType | null
  }

  type GetEvaluacionesGroupByPayload<T extends EvaluacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EvaluacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluacionesGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluacionesGroupByOutputType[P]>
        }
      >
    >


  export type evaluacionesSelect = {
    Evaluacion_ID?: boolean
    Clase_ID?: boolean
    Fecha?: boolean
    Detalles?: boolean
  }


  export type evaluacionesGetPayload<S extends boolean | null | undefined | evaluacionesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? evaluaciones :
    S extends undefined ? never :
    S extends { include: any } & (evaluacionesArgs | evaluacionesFindManyArgs)
    ? evaluaciones 
    : S extends { select: any } & (evaluacionesArgs | evaluacionesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof evaluaciones ? evaluaciones[P] : never
  } 
      : evaluaciones


  type evaluacionesCountArgs = 
    Omit<evaluacionesFindManyArgs, 'select' | 'include'> & {
      select?: EvaluacionesCountAggregateInputType | true
    }

  export interface evaluacionesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Evaluaciones that matches the filter.
     * @param {evaluacionesFindUniqueArgs} args - Arguments to find a Evaluaciones
     * @example
     * // Get one Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends evaluacionesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, evaluacionesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'evaluaciones'> extends True ? Prisma__evaluacionesClient<evaluacionesGetPayload<T>> : Prisma__evaluacionesClient<evaluacionesGetPayload<T> | null, null>

    /**
     * Find one Evaluaciones that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {evaluacionesFindUniqueOrThrowArgs} args - Arguments to find a Evaluaciones
     * @example
     * // Get one Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends evaluacionesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, evaluacionesFindUniqueOrThrowArgs>
    ): Prisma__evaluacionesClient<evaluacionesGetPayload<T>>

    /**
     * Find the first Evaluaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluacionesFindFirstArgs} args - Arguments to find a Evaluaciones
     * @example
     * // Get one Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends evaluacionesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, evaluacionesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'evaluaciones'> extends True ? Prisma__evaluacionesClient<evaluacionesGetPayload<T>> : Prisma__evaluacionesClient<evaluacionesGetPayload<T> | null, null>

    /**
     * Find the first Evaluaciones that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluacionesFindFirstOrThrowArgs} args - Arguments to find a Evaluaciones
     * @example
     * // Get one Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends evaluacionesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, evaluacionesFindFirstOrThrowArgs>
    ): Prisma__evaluacionesClient<evaluacionesGetPayload<T>>

    /**
     * Find zero or more Evaluaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluacionesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findMany()
     * 
     * // Get first 10 Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findMany({ take: 10 })
     * 
     * // Only select the `Evaluacion_ID`
     * const evaluacionesWithEvaluacion_IDOnly = await prisma.evaluaciones.findMany({ select: { Evaluacion_ID: true } })
     * 
    **/
    findMany<T extends evaluacionesFindManyArgs>(
      args?: SelectSubset<T, evaluacionesFindManyArgs>
    ): Prisma.PrismaPromise<Array<evaluacionesGetPayload<T>>>

    /**
     * Create a Evaluaciones.
     * @param {evaluacionesCreateArgs} args - Arguments to create a Evaluaciones.
     * @example
     * // Create one Evaluaciones
     * const Evaluaciones = await prisma.evaluaciones.create({
     *   data: {
     *     // ... data to create a Evaluaciones
     *   }
     * })
     * 
    **/
    create<T extends evaluacionesCreateArgs>(
      args: SelectSubset<T, evaluacionesCreateArgs>
    ): Prisma__evaluacionesClient<evaluacionesGetPayload<T>>

    /**
     * Create many Evaluaciones.
     *     @param {evaluacionesCreateManyArgs} args - Arguments to create many Evaluaciones.
     *     @example
     *     // Create many Evaluaciones
     *     const evaluaciones = await prisma.evaluaciones.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends evaluacionesCreateManyArgs>(
      args?: SelectSubset<T, evaluacionesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evaluaciones.
     * @param {evaluacionesDeleteArgs} args - Arguments to delete one Evaluaciones.
     * @example
     * // Delete one Evaluaciones
     * const Evaluaciones = await prisma.evaluaciones.delete({
     *   where: {
     *     // ... filter to delete one Evaluaciones
     *   }
     * })
     * 
    **/
    delete<T extends evaluacionesDeleteArgs>(
      args: SelectSubset<T, evaluacionesDeleteArgs>
    ): Prisma__evaluacionesClient<evaluacionesGetPayload<T>>

    /**
     * Update one Evaluaciones.
     * @param {evaluacionesUpdateArgs} args - Arguments to update one Evaluaciones.
     * @example
     * // Update one Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends evaluacionesUpdateArgs>(
      args: SelectSubset<T, evaluacionesUpdateArgs>
    ): Prisma__evaluacionesClient<evaluacionesGetPayload<T>>

    /**
     * Delete zero or more Evaluaciones.
     * @param {evaluacionesDeleteManyArgs} args - Arguments to filter Evaluaciones to delete.
     * @example
     * // Delete a few Evaluaciones
     * const { count } = await prisma.evaluaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends evaluacionesDeleteManyArgs>(
      args?: SelectSubset<T, evaluacionesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends evaluacionesUpdateManyArgs>(
      args: SelectSubset<T, evaluacionesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evaluaciones.
     * @param {evaluacionesUpsertArgs} args - Arguments to update or create a Evaluaciones.
     * @example
     * // Update or create a Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.upsert({
     *   create: {
     *     // ... data to create a Evaluaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluaciones we want to update
     *   }
     * })
    **/
    upsert<T extends evaluacionesUpsertArgs>(
      args: SelectSubset<T, evaluacionesUpsertArgs>
    ): Prisma__evaluacionesClient<evaluacionesGetPayload<T>>

    /**
     * Count the number of Evaluaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluacionesCountArgs} args - Arguments to filter Evaluaciones to count.
     * @example
     * // Count the number of Evaluaciones
     * const count = await prisma.evaluaciones.count({
     *   where: {
     *     // ... the filter for the Evaluaciones we want to count
     *   }
     * })
    **/
    count<T extends evaluacionesCountArgs>(
      args?: Subset<T, evaluacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluacionesAggregateArgs>(args: Subset<T, EvaluacionesAggregateArgs>): Prisma.PrismaPromise<GetEvaluacionesAggregateType<T>>

    /**
     * Group by Evaluaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluacionesGroupByArgs['orderBy'] }
        : { orderBy?: EvaluacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for evaluaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__evaluacionesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * evaluaciones base type for findUnique actions
   */
  export type evaluacionesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the evaluaciones
     */
    select?: evaluacionesSelect | null
    /**
     * Filter, which evaluaciones to fetch.
     */
    where: evaluacionesWhereUniqueInput
  }

  /**
   * evaluaciones findUnique
   */
  export interface evaluacionesFindUniqueArgs extends evaluacionesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * evaluaciones findUniqueOrThrow
   */
  export type evaluacionesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the evaluaciones
     */
    select?: evaluacionesSelect | null
    /**
     * Filter, which evaluaciones to fetch.
     */
    where: evaluacionesWhereUniqueInput
  }


  /**
   * evaluaciones base type for findFirst actions
   */
  export type evaluacionesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the evaluaciones
     */
    select?: evaluacionesSelect | null
    /**
     * Filter, which evaluaciones to fetch.
     */
    where?: evaluacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evaluaciones to fetch.
     */
    orderBy?: Enumerable<evaluacionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evaluaciones.
     */
    cursor?: evaluacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evaluaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evaluaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evaluaciones.
     */
    distinct?: Enumerable<EvaluacionesScalarFieldEnum>
  }

  /**
   * evaluaciones findFirst
   */
  export interface evaluacionesFindFirstArgs extends evaluacionesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * evaluaciones findFirstOrThrow
   */
  export type evaluacionesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the evaluaciones
     */
    select?: evaluacionesSelect | null
    /**
     * Filter, which evaluaciones to fetch.
     */
    where?: evaluacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evaluaciones to fetch.
     */
    orderBy?: Enumerable<evaluacionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evaluaciones.
     */
    cursor?: evaluacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evaluaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evaluaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evaluaciones.
     */
    distinct?: Enumerable<EvaluacionesScalarFieldEnum>
  }


  /**
   * evaluaciones findMany
   */
  export type evaluacionesFindManyArgs = {
    /**
     * Select specific fields to fetch from the evaluaciones
     */
    select?: evaluacionesSelect | null
    /**
     * Filter, which evaluaciones to fetch.
     */
    where?: evaluacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evaluaciones to fetch.
     */
    orderBy?: Enumerable<evaluacionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing evaluaciones.
     */
    cursor?: evaluacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evaluaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evaluaciones.
     */
    skip?: number
    distinct?: Enumerable<EvaluacionesScalarFieldEnum>
  }


  /**
   * evaluaciones create
   */
  export type evaluacionesCreateArgs = {
    /**
     * Select specific fields to fetch from the evaluaciones
     */
    select?: evaluacionesSelect | null
    /**
     * The data needed to create a evaluaciones.
     */
    data: XOR<evaluacionesCreateInput, evaluacionesUncheckedCreateInput>
  }


  /**
   * evaluaciones createMany
   */
  export type evaluacionesCreateManyArgs = {
    /**
     * The data used to create many evaluaciones.
     */
    data: Enumerable<evaluacionesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * evaluaciones update
   */
  export type evaluacionesUpdateArgs = {
    /**
     * Select specific fields to fetch from the evaluaciones
     */
    select?: evaluacionesSelect | null
    /**
     * The data needed to update a evaluaciones.
     */
    data: XOR<evaluacionesUpdateInput, evaluacionesUncheckedUpdateInput>
    /**
     * Choose, which evaluaciones to update.
     */
    where: evaluacionesWhereUniqueInput
  }


  /**
   * evaluaciones updateMany
   */
  export type evaluacionesUpdateManyArgs = {
    /**
     * The data used to update evaluaciones.
     */
    data: XOR<evaluacionesUpdateManyMutationInput, evaluacionesUncheckedUpdateManyInput>
    /**
     * Filter which evaluaciones to update
     */
    where?: evaluacionesWhereInput
  }


  /**
   * evaluaciones upsert
   */
  export type evaluacionesUpsertArgs = {
    /**
     * Select specific fields to fetch from the evaluaciones
     */
    select?: evaluacionesSelect | null
    /**
     * The filter to search for the evaluaciones to update in case it exists.
     */
    where: evaluacionesWhereUniqueInput
    /**
     * In case the evaluaciones found by the `where` argument doesn't exist, create a new evaluaciones with this data.
     */
    create: XOR<evaluacionesCreateInput, evaluacionesUncheckedCreateInput>
    /**
     * In case the evaluaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<evaluacionesUpdateInput, evaluacionesUncheckedUpdateInput>
  }


  /**
   * evaluaciones delete
   */
  export type evaluacionesDeleteArgs = {
    /**
     * Select specific fields to fetch from the evaluaciones
     */
    select?: evaluacionesSelect | null
    /**
     * Filter which evaluaciones to delete.
     */
    where: evaluacionesWhereUniqueInput
  }


  /**
   * evaluaciones deleteMany
   */
  export type evaluacionesDeleteManyArgs = {
    /**
     * Filter which evaluaciones to delete
     */
    where?: evaluacionesWhereInput
  }


  /**
   * evaluaciones without action
   */
  export type evaluacionesArgs = {
    /**
     * Select specific fields to fetch from the evaluaciones
     */
    select?: evaluacionesSelect | null
  }



  /**
   * Model faltas
   */


  export type AggregateFaltas = {
    _count: FaltasCountAggregateOutputType | null
    _avg: FaltasAvgAggregateOutputType | null
    _sum: FaltasSumAggregateOutputType | null
    _min: FaltasMinAggregateOutputType | null
    _max: FaltasMaxAggregateOutputType | null
  }

  export type FaltasAvgAggregateOutputType = {
    Falta_ID: number | null
    DNI_Alumno: number | null
    Tipo: Decimal | null
  }

  export type FaltasSumAggregateOutputType = {
    Falta_ID: number | null
    DNI_Alumno: number | null
    Tipo: Decimal | null
  }

  export type FaltasMinAggregateOutputType = {
    Falta_ID: number | null
    DNI_Alumno: number | null
    Fecha: Date | null
    Tipo: Decimal | null
    jutificada: boolean | null
  }

  export type FaltasMaxAggregateOutputType = {
    Falta_ID: number | null
    DNI_Alumno: number | null
    Fecha: Date | null
    Tipo: Decimal | null
    jutificada: boolean | null
  }

  export type FaltasCountAggregateOutputType = {
    Falta_ID: number
    DNI_Alumno: number
    Fecha: number
    Tipo: number
    jutificada: number
    _all: number
  }


  export type FaltasAvgAggregateInputType = {
    Falta_ID?: true
    DNI_Alumno?: true
    Tipo?: true
  }

  export type FaltasSumAggregateInputType = {
    Falta_ID?: true
    DNI_Alumno?: true
    Tipo?: true
  }

  export type FaltasMinAggregateInputType = {
    Falta_ID?: true
    DNI_Alumno?: true
    Fecha?: true
    Tipo?: true
    jutificada?: true
  }

  export type FaltasMaxAggregateInputType = {
    Falta_ID?: true
    DNI_Alumno?: true
    Fecha?: true
    Tipo?: true
    jutificada?: true
  }

  export type FaltasCountAggregateInputType = {
    Falta_ID?: true
    DNI_Alumno?: true
    Fecha?: true
    Tipo?: true
    jutificada?: true
    _all?: true
  }

  export type FaltasAggregateArgs = {
    /**
     * Filter which faltas to aggregate.
     */
    where?: faltasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faltas to fetch.
     */
    orderBy?: Enumerable<faltasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: faltasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faltas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faltas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned faltas
    **/
    _count?: true | FaltasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaltasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaltasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaltasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaltasMaxAggregateInputType
  }

  export type GetFaltasAggregateType<T extends FaltasAggregateArgs> = {
        [P in keyof T & keyof AggregateFaltas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaltas[P]>
      : GetScalarType<T[P], AggregateFaltas[P]>
  }




  export type FaltasGroupByArgs = {
    where?: faltasWhereInput
    orderBy?: Enumerable<faltasOrderByWithAggregationInput>
    by: FaltasScalarFieldEnum[]
    having?: faltasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaltasCountAggregateInputType | true
    _avg?: FaltasAvgAggregateInputType
    _sum?: FaltasSumAggregateInputType
    _min?: FaltasMinAggregateInputType
    _max?: FaltasMaxAggregateInputType
  }


  export type FaltasGroupByOutputType = {
    Falta_ID: number
    DNI_Alumno: number
    Fecha: Date | null
    Tipo: Decimal
    jutificada: boolean
    _count: FaltasCountAggregateOutputType | null
    _avg: FaltasAvgAggregateOutputType | null
    _sum: FaltasSumAggregateOutputType | null
    _min: FaltasMinAggregateOutputType | null
    _max: FaltasMaxAggregateOutputType | null
  }

  type GetFaltasGroupByPayload<T extends FaltasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FaltasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaltasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaltasGroupByOutputType[P]>
            : GetScalarType<T[P], FaltasGroupByOutputType[P]>
        }
      >
    >


  export type faltasSelect = {
    Falta_ID?: boolean
    DNI_Alumno?: boolean
    Fecha?: boolean
    Tipo?: boolean
    jutificada?: boolean
    Alumno?: boolean | alumnoArgs
  }


  export type faltasInclude = {
    Alumno?: boolean | alumnoArgs
  }

  export type faltasGetPayload<S extends boolean | null | undefined | faltasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? faltas :
    S extends undefined ? never :
    S extends { include: any } & (faltasArgs | faltasFindManyArgs)
    ? faltas  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Alumno' ? alumnoGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (faltasArgs | faltasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Alumno' ? alumnoGetPayload<S['select'][P]> | null :  P extends keyof faltas ? faltas[P] : never
  } 
      : faltas


  type faltasCountArgs = 
    Omit<faltasFindManyArgs, 'select' | 'include'> & {
      select?: FaltasCountAggregateInputType | true
    }

  export interface faltasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Faltas that matches the filter.
     * @param {faltasFindUniqueArgs} args - Arguments to find a Faltas
     * @example
     * // Get one Faltas
     * const faltas = await prisma.faltas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends faltasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, faltasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'faltas'> extends True ? Prisma__faltasClient<faltasGetPayload<T>> : Prisma__faltasClient<faltasGetPayload<T> | null, null>

    /**
     * Find one Faltas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {faltasFindUniqueOrThrowArgs} args - Arguments to find a Faltas
     * @example
     * // Get one Faltas
     * const faltas = await prisma.faltas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends faltasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, faltasFindUniqueOrThrowArgs>
    ): Prisma__faltasClient<faltasGetPayload<T>>

    /**
     * Find the first Faltas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faltasFindFirstArgs} args - Arguments to find a Faltas
     * @example
     * // Get one Faltas
     * const faltas = await prisma.faltas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends faltasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, faltasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'faltas'> extends True ? Prisma__faltasClient<faltasGetPayload<T>> : Prisma__faltasClient<faltasGetPayload<T> | null, null>

    /**
     * Find the first Faltas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faltasFindFirstOrThrowArgs} args - Arguments to find a Faltas
     * @example
     * // Get one Faltas
     * const faltas = await prisma.faltas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends faltasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, faltasFindFirstOrThrowArgs>
    ): Prisma__faltasClient<faltasGetPayload<T>>

    /**
     * Find zero or more Faltas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faltasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faltas
     * const faltas = await prisma.faltas.findMany()
     * 
     * // Get first 10 Faltas
     * const faltas = await prisma.faltas.findMany({ take: 10 })
     * 
     * // Only select the `Falta_ID`
     * const faltasWithFalta_IDOnly = await prisma.faltas.findMany({ select: { Falta_ID: true } })
     * 
    **/
    findMany<T extends faltasFindManyArgs>(
      args?: SelectSubset<T, faltasFindManyArgs>
    ): Prisma.PrismaPromise<Array<faltasGetPayload<T>>>

    /**
     * Create a Faltas.
     * @param {faltasCreateArgs} args - Arguments to create a Faltas.
     * @example
     * // Create one Faltas
     * const Faltas = await prisma.faltas.create({
     *   data: {
     *     // ... data to create a Faltas
     *   }
     * })
     * 
    **/
    create<T extends faltasCreateArgs>(
      args: SelectSubset<T, faltasCreateArgs>
    ): Prisma__faltasClient<faltasGetPayload<T>>

    /**
     * Create many Faltas.
     *     @param {faltasCreateManyArgs} args - Arguments to create many Faltas.
     *     @example
     *     // Create many Faltas
     *     const faltas = await prisma.faltas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends faltasCreateManyArgs>(
      args?: SelectSubset<T, faltasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faltas.
     * @param {faltasDeleteArgs} args - Arguments to delete one Faltas.
     * @example
     * // Delete one Faltas
     * const Faltas = await prisma.faltas.delete({
     *   where: {
     *     // ... filter to delete one Faltas
     *   }
     * })
     * 
    **/
    delete<T extends faltasDeleteArgs>(
      args: SelectSubset<T, faltasDeleteArgs>
    ): Prisma__faltasClient<faltasGetPayload<T>>

    /**
     * Update one Faltas.
     * @param {faltasUpdateArgs} args - Arguments to update one Faltas.
     * @example
     * // Update one Faltas
     * const faltas = await prisma.faltas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends faltasUpdateArgs>(
      args: SelectSubset<T, faltasUpdateArgs>
    ): Prisma__faltasClient<faltasGetPayload<T>>

    /**
     * Delete zero or more Faltas.
     * @param {faltasDeleteManyArgs} args - Arguments to filter Faltas to delete.
     * @example
     * // Delete a few Faltas
     * const { count } = await prisma.faltas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends faltasDeleteManyArgs>(
      args?: SelectSubset<T, faltasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faltas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faltasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faltas
     * const faltas = await prisma.faltas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends faltasUpdateManyArgs>(
      args: SelectSubset<T, faltasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faltas.
     * @param {faltasUpsertArgs} args - Arguments to update or create a Faltas.
     * @example
     * // Update or create a Faltas
     * const faltas = await prisma.faltas.upsert({
     *   create: {
     *     // ... data to create a Faltas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faltas we want to update
     *   }
     * })
    **/
    upsert<T extends faltasUpsertArgs>(
      args: SelectSubset<T, faltasUpsertArgs>
    ): Prisma__faltasClient<faltasGetPayload<T>>

    /**
     * Count the number of Faltas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faltasCountArgs} args - Arguments to filter Faltas to count.
     * @example
     * // Count the number of Faltas
     * const count = await prisma.faltas.count({
     *   where: {
     *     // ... the filter for the Faltas we want to count
     *   }
     * })
    **/
    count<T extends faltasCountArgs>(
      args?: Subset<T, faltasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaltasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faltas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaltasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaltasAggregateArgs>(args: Subset<T, FaltasAggregateArgs>): Prisma.PrismaPromise<GetFaltasAggregateType<T>>

    /**
     * Group by Faltas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaltasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaltasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaltasGroupByArgs['orderBy'] }
        : { orderBy?: FaltasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaltasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaltasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for faltas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__faltasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Alumno<T extends alumnoArgs= {}>(args?: Subset<T, alumnoArgs>): Prisma__alumnoClient<alumnoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * faltas base type for findUnique actions
   */
  export type faltasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
    /**
     * Filter, which faltas to fetch.
     */
    where: faltasWhereUniqueInput
  }

  /**
   * faltas findUnique
   */
  export interface faltasFindUniqueArgs extends faltasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * faltas findUniqueOrThrow
   */
  export type faltasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
    /**
     * Filter, which faltas to fetch.
     */
    where: faltasWhereUniqueInput
  }


  /**
   * faltas base type for findFirst actions
   */
  export type faltasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
    /**
     * Filter, which faltas to fetch.
     */
    where?: faltasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faltas to fetch.
     */
    orderBy?: Enumerable<faltasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faltas.
     */
    cursor?: faltasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faltas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faltas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faltas.
     */
    distinct?: Enumerable<FaltasScalarFieldEnum>
  }

  /**
   * faltas findFirst
   */
  export interface faltasFindFirstArgs extends faltasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * faltas findFirstOrThrow
   */
  export type faltasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
    /**
     * Filter, which faltas to fetch.
     */
    where?: faltasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faltas to fetch.
     */
    orderBy?: Enumerable<faltasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faltas.
     */
    cursor?: faltasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faltas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faltas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faltas.
     */
    distinct?: Enumerable<FaltasScalarFieldEnum>
  }


  /**
   * faltas findMany
   */
  export type faltasFindManyArgs = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
    /**
     * Filter, which faltas to fetch.
     */
    where?: faltasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faltas to fetch.
     */
    orderBy?: Enumerable<faltasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing faltas.
     */
    cursor?: faltasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faltas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faltas.
     */
    skip?: number
    distinct?: Enumerable<FaltasScalarFieldEnum>
  }


  /**
   * faltas create
   */
  export type faltasCreateArgs = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
    /**
     * The data needed to create a faltas.
     */
    data: XOR<faltasCreateInput, faltasUncheckedCreateInput>
  }


  /**
   * faltas createMany
   */
  export type faltasCreateManyArgs = {
    /**
     * The data used to create many faltas.
     */
    data: Enumerable<faltasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * faltas update
   */
  export type faltasUpdateArgs = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
    /**
     * The data needed to update a faltas.
     */
    data: XOR<faltasUpdateInput, faltasUncheckedUpdateInput>
    /**
     * Choose, which faltas to update.
     */
    where: faltasWhereUniqueInput
  }


  /**
   * faltas updateMany
   */
  export type faltasUpdateManyArgs = {
    /**
     * The data used to update faltas.
     */
    data: XOR<faltasUpdateManyMutationInput, faltasUncheckedUpdateManyInput>
    /**
     * Filter which faltas to update
     */
    where?: faltasWhereInput
  }


  /**
   * faltas upsert
   */
  export type faltasUpsertArgs = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
    /**
     * The filter to search for the faltas to update in case it exists.
     */
    where: faltasWhereUniqueInput
    /**
     * In case the faltas found by the `where` argument doesn't exist, create a new faltas with this data.
     */
    create: XOR<faltasCreateInput, faltasUncheckedCreateInput>
    /**
     * In case the faltas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<faltasUpdateInput, faltasUncheckedUpdateInput>
  }


  /**
   * faltas delete
   */
  export type faltasDeleteArgs = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
    /**
     * Filter which faltas to delete.
     */
    where: faltasWhereUniqueInput
  }


  /**
   * faltas deleteMany
   */
  export type faltasDeleteManyArgs = {
    /**
     * Filter which faltas to delete
     */
    where?: faltasWhereInput
  }


  /**
   * faltas without action
   */
  export type faltasArgs = {
    /**
     * Select specific fields to fetch from the faltas
     */
    select?: faltasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faltasInclude | null
  }



  /**
   * Model materia
   */


  export type AggregateMateria = {
    _count: MateriaCountAggregateOutputType | null
    _avg: MateriaAvgAggregateOutputType | null
    _sum: MateriaSumAggregateOutputType | null
    _min: MateriaMinAggregateOutputType | null
    _max: MateriaMaxAggregateOutputType | null
  }

  export type MateriaAvgAggregateOutputType = {
    Materia_ID: number | null
    Ano_escolar: number | null
    Horas_Semanales: number | null
  }

  export type MateriaSumAggregateOutputType = {
    Materia_ID: number | null
    Ano_escolar: number | null
    Horas_Semanales: number | null
  }

  export type MateriaMinAggregateOutputType = {
    Materia_ID: number | null
    Nombre: string | null
    Ano_escolar: number | null
    Horas_Semanales: number | null
  }

  export type MateriaMaxAggregateOutputType = {
    Materia_ID: number | null
    Nombre: string | null
    Ano_escolar: number | null
    Horas_Semanales: number | null
  }

  export type MateriaCountAggregateOutputType = {
    Materia_ID: number
    Nombre: number
    Ano_escolar: number
    Horas_Semanales: number
    _all: number
  }


  export type MateriaAvgAggregateInputType = {
    Materia_ID?: true
    Ano_escolar?: true
    Horas_Semanales?: true
  }

  export type MateriaSumAggregateInputType = {
    Materia_ID?: true
    Ano_escolar?: true
    Horas_Semanales?: true
  }

  export type MateriaMinAggregateInputType = {
    Materia_ID?: true
    Nombre?: true
    Ano_escolar?: true
    Horas_Semanales?: true
  }

  export type MateriaMaxAggregateInputType = {
    Materia_ID?: true
    Nombre?: true
    Ano_escolar?: true
    Horas_Semanales?: true
  }

  export type MateriaCountAggregateInputType = {
    Materia_ID?: true
    Nombre?: true
    Ano_escolar?: true
    Horas_Semanales?: true
    _all?: true
  }

  export type MateriaAggregateArgs = {
    /**
     * Filter which materia to aggregate.
     */
    where?: materiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materias to fetch.
     */
    orderBy?: Enumerable<materiaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: materiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned materias
    **/
    _count?: true | MateriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MateriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MateriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MateriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MateriaMaxAggregateInputType
  }

  export type GetMateriaAggregateType<T extends MateriaAggregateArgs> = {
        [P in keyof T & keyof AggregateMateria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateria[P]>
      : GetScalarType<T[P], AggregateMateria[P]>
  }




  export type MateriaGroupByArgs = {
    where?: materiaWhereInput
    orderBy?: Enumerable<materiaOrderByWithAggregationInput>
    by: MateriaScalarFieldEnum[]
    having?: materiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MateriaCountAggregateInputType | true
    _avg?: MateriaAvgAggregateInputType
    _sum?: MateriaSumAggregateInputType
    _min?: MateriaMinAggregateInputType
    _max?: MateriaMaxAggregateInputType
  }


  export type MateriaGroupByOutputType = {
    Materia_ID: number
    Nombre: string
    Ano_escolar: number
    Horas_Semanales: number
    _count: MateriaCountAggregateOutputType | null
    _avg: MateriaAvgAggregateOutputType | null
    _sum: MateriaSumAggregateOutputType | null
    _min: MateriaMinAggregateOutputType | null
    _max: MateriaMaxAggregateOutputType | null
  }

  type GetMateriaGroupByPayload<T extends MateriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MateriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MateriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MateriaGroupByOutputType[P]>
            : GetScalarType<T[P], MateriaGroupByOutputType[P]>
        }
      >
    >


  export type materiaSelect = {
    Materia_ID?: boolean
    Nombre?: boolean
    Ano_escolar?: boolean
    Horas_Semanales?: boolean
    cursos?: boolean | materia$cursosArgs
    _count?: boolean | MateriaCountOutputTypeArgs
  }


  export type materiaInclude = {
    cursos?: boolean | materia$cursosArgs
    _count?: boolean | MateriaCountOutputTypeArgs
  }

  export type materiaGetPayload<S extends boolean | null | undefined | materiaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? materia :
    S extends undefined ? never :
    S extends { include: any } & (materiaArgs | materiaFindManyArgs)
    ? materia  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cursos' ? Array < ClaseGetPayload<S['include'][P]>>  :
        P extends '_count' ? MateriaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (materiaArgs | materiaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cursos' ? Array < ClaseGetPayload<S['select'][P]>>  :
        P extends '_count' ? MateriaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof materia ? materia[P] : never
  } 
      : materia


  type materiaCountArgs = 
    Omit<materiaFindManyArgs, 'select' | 'include'> & {
      select?: MateriaCountAggregateInputType | true
    }

  export interface materiaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Materia that matches the filter.
     * @param {materiaFindUniqueArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends materiaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, materiaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'materia'> extends True ? Prisma__materiaClient<materiaGetPayload<T>> : Prisma__materiaClient<materiaGetPayload<T> | null, null>

    /**
     * Find one Materia that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {materiaFindUniqueOrThrowArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends materiaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, materiaFindUniqueOrThrowArgs>
    ): Prisma__materiaClient<materiaGetPayload<T>>

    /**
     * Find the first Materia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materiaFindFirstArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends materiaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, materiaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'materia'> extends True ? Prisma__materiaClient<materiaGetPayload<T>> : Prisma__materiaClient<materiaGetPayload<T> | null, null>

    /**
     * Find the first Materia that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materiaFindFirstOrThrowArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends materiaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, materiaFindFirstOrThrowArgs>
    ): Prisma__materiaClient<materiaGetPayload<T>>

    /**
     * Find zero or more Materias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materiaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materias
     * const materias = await prisma.materia.findMany()
     * 
     * // Get first 10 Materias
     * const materias = await prisma.materia.findMany({ take: 10 })
     * 
     * // Only select the `Materia_ID`
     * const materiaWithMateria_IDOnly = await prisma.materia.findMany({ select: { Materia_ID: true } })
     * 
    **/
    findMany<T extends materiaFindManyArgs>(
      args?: SelectSubset<T, materiaFindManyArgs>
    ): Prisma.PrismaPromise<Array<materiaGetPayload<T>>>

    /**
     * Create a Materia.
     * @param {materiaCreateArgs} args - Arguments to create a Materia.
     * @example
     * // Create one Materia
     * const Materia = await prisma.materia.create({
     *   data: {
     *     // ... data to create a Materia
     *   }
     * })
     * 
    **/
    create<T extends materiaCreateArgs>(
      args: SelectSubset<T, materiaCreateArgs>
    ): Prisma__materiaClient<materiaGetPayload<T>>

    /**
     * Create many Materias.
     *     @param {materiaCreateManyArgs} args - Arguments to create many Materias.
     *     @example
     *     // Create many Materias
     *     const materia = await prisma.materia.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends materiaCreateManyArgs>(
      args?: SelectSubset<T, materiaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Materia.
     * @param {materiaDeleteArgs} args - Arguments to delete one Materia.
     * @example
     * // Delete one Materia
     * const Materia = await prisma.materia.delete({
     *   where: {
     *     // ... filter to delete one Materia
     *   }
     * })
     * 
    **/
    delete<T extends materiaDeleteArgs>(
      args: SelectSubset<T, materiaDeleteArgs>
    ): Prisma__materiaClient<materiaGetPayload<T>>

    /**
     * Update one Materia.
     * @param {materiaUpdateArgs} args - Arguments to update one Materia.
     * @example
     * // Update one Materia
     * const materia = await prisma.materia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends materiaUpdateArgs>(
      args: SelectSubset<T, materiaUpdateArgs>
    ): Prisma__materiaClient<materiaGetPayload<T>>

    /**
     * Delete zero or more Materias.
     * @param {materiaDeleteManyArgs} args - Arguments to filter Materias to delete.
     * @example
     * // Delete a few Materias
     * const { count } = await prisma.materia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends materiaDeleteManyArgs>(
      args?: SelectSubset<T, materiaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materias
     * const materia = await prisma.materia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends materiaUpdateManyArgs>(
      args: SelectSubset<T, materiaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materia.
     * @param {materiaUpsertArgs} args - Arguments to update or create a Materia.
     * @example
     * // Update or create a Materia
     * const materia = await prisma.materia.upsert({
     *   create: {
     *     // ... data to create a Materia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materia we want to update
     *   }
     * })
    **/
    upsert<T extends materiaUpsertArgs>(
      args: SelectSubset<T, materiaUpsertArgs>
    ): Prisma__materiaClient<materiaGetPayload<T>>

    /**
     * Count the number of Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materiaCountArgs} args - Arguments to filter Materias to count.
     * @example
     * // Count the number of Materias
     * const count = await prisma.materia.count({
     *   where: {
     *     // ... the filter for the Materias we want to count
     *   }
     * })
    **/
    count<T extends materiaCountArgs>(
      args?: Subset<T, materiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MateriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MateriaAggregateArgs>(args: Subset<T, MateriaAggregateArgs>): Prisma.PrismaPromise<GetMateriaAggregateType<T>>

    /**
     * Group by Materia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MateriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MateriaGroupByArgs['orderBy'] }
        : { orderBy?: MateriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MateriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMateriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for materia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__materiaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cursos<T extends materia$cursosArgs= {}>(args?: Subset<T, materia$cursosArgs>): Prisma.PrismaPromise<Array<ClaseGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * materia base type for findUnique actions
   */
  export type materiaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the materia
     */
    select?: materiaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiaInclude | null
    /**
     * Filter, which materia to fetch.
     */
    where: materiaWhereUniqueInput
  }

  /**
   * materia findUnique
   */
  export interface materiaFindUniqueArgs extends materiaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * materia findUniqueOrThrow
   */
  export type materiaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the materia
     */
    select?: materiaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiaInclude | null
    /**
     * Filter, which materia to fetch.
     */
    where: materiaWhereUniqueInput
  }


  /**
   * materia base type for findFirst actions
   */
  export type materiaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the materia
     */
    select?: materiaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiaInclude | null
    /**
     * Filter, which materia to fetch.
     */
    where?: materiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materias to fetch.
     */
    orderBy?: Enumerable<materiaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materias.
     */
    cursor?: materiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materias.
     */
    distinct?: Enumerable<MateriaScalarFieldEnum>
  }

  /**
   * materia findFirst
   */
  export interface materiaFindFirstArgs extends materiaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * materia findFirstOrThrow
   */
  export type materiaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the materia
     */
    select?: materiaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiaInclude | null
    /**
     * Filter, which materia to fetch.
     */
    where?: materiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materias to fetch.
     */
    orderBy?: Enumerable<materiaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materias.
     */
    cursor?: materiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materias.
     */
    distinct?: Enumerable<MateriaScalarFieldEnum>
  }


  /**
   * materia findMany
   */
  export type materiaFindManyArgs = {
    /**
     * Select specific fields to fetch from the materia
     */
    select?: materiaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiaInclude | null
    /**
     * Filter, which materias to fetch.
     */
    where?: materiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materias to fetch.
     */
    orderBy?: Enumerable<materiaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing materias.
     */
    cursor?: materiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materias.
     */
    skip?: number
    distinct?: Enumerable<MateriaScalarFieldEnum>
  }


  /**
   * materia create
   */
  export type materiaCreateArgs = {
    /**
     * Select specific fields to fetch from the materia
     */
    select?: materiaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiaInclude | null
    /**
     * The data needed to create a materia.
     */
    data: XOR<materiaCreateInput, materiaUncheckedCreateInput>
  }


  /**
   * materia createMany
   */
  export type materiaCreateManyArgs = {
    /**
     * The data used to create many materias.
     */
    data: Enumerable<materiaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * materia update
   */
  export type materiaUpdateArgs = {
    /**
     * Select specific fields to fetch from the materia
     */
    select?: materiaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiaInclude | null
    /**
     * The data needed to update a materia.
     */
    data: XOR<materiaUpdateInput, materiaUncheckedUpdateInput>
    /**
     * Choose, which materia to update.
     */
    where: materiaWhereUniqueInput
  }


  /**
   * materia updateMany
   */
  export type materiaUpdateManyArgs = {
    /**
     * The data used to update materias.
     */
    data: XOR<materiaUpdateManyMutationInput, materiaUncheckedUpdateManyInput>
    /**
     * Filter which materias to update
     */
    where?: materiaWhereInput
  }


  /**
   * materia upsert
   */
  export type materiaUpsertArgs = {
    /**
     * Select specific fields to fetch from the materia
     */
    select?: materiaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiaInclude | null
    /**
     * The filter to search for the materia to update in case it exists.
     */
    where: materiaWhereUniqueInput
    /**
     * In case the materia found by the `where` argument doesn't exist, create a new materia with this data.
     */
    create: XOR<materiaCreateInput, materiaUncheckedCreateInput>
    /**
     * In case the materia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<materiaUpdateInput, materiaUncheckedUpdateInput>
  }


  /**
   * materia delete
   */
  export type materiaDeleteArgs = {
    /**
     * Select specific fields to fetch from the materia
     */
    select?: materiaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiaInclude | null
    /**
     * Filter which materia to delete.
     */
    where: materiaWhereUniqueInput
  }


  /**
   * materia deleteMany
   */
  export type materiaDeleteManyArgs = {
    /**
     * Filter which materias to delete
     */
    where?: materiaWhereInput
  }


  /**
   * materia.cursos
   */
  export type materia$cursosArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    where?: ClaseWhereInput
    orderBy?: Enumerable<ClaseOrderByWithRelationInput>
    cursor?: ClaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClaseScalarFieldEnum>
  }


  /**
   * materia without action
   */
  export type materiaArgs = {
    /**
     * Select specific fields to fetch from the materia
     */
    select?: materiaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiaInclude | null
  }



  /**
   * Model notas
   */


  export type AggregateNotas = {
    _count: NotasCountAggregateOutputType | null
    _avg: NotasAvgAggregateOutputType | null
    _sum: NotasSumAggregateOutputType | null
    _min: NotasMinAggregateOutputType | null
    _max: NotasMaxAggregateOutputType | null
  }

  export type NotasAvgAggregateOutputType = {
    Notas_ID: number | null
    Nota: Decimal | null
    DNI_Alumno: number | null
    Evaluacion_ID: number | null
  }

  export type NotasSumAggregateOutputType = {
    Notas_ID: number | null
    Nota: Decimal | null
    DNI_Alumno: number | null
    Evaluacion_ID: number | null
  }

  export type NotasMinAggregateOutputType = {
    Notas_ID: number | null
    Nota: Decimal | null
    DNI_Alumno: number | null
    Evaluacion_ID: number | null
  }

  export type NotasMaxAggregateOutputType = {
    Notas_ID: number | null
    Nota: Decimal | null
    DNI_Alumno: number | null
    Evaluacion_ID: number | null
  }

  export type NotasCountAggregateOutputType = {
    Notas_ID: number
    Nota: number
    DNI_Alumno: number
    Evaluacion_ID: number
    _all: number
  }


  export type NotasAvgAggregateInputType = {
    Notas_ID?: true
    Nota?: true
    DNI_Alumno?: true
    Evaluacion_ID?: true
  }

  export type NotasSumAggregateInputType = {
    Notas_ID?: true
    Nota?: true
    DNI_Alumno?: true
    Evaluacion_ID?: true
  }

  export type NotasMinAggregateInputType = {
    Notas_ID?: true
    Nota?: true
    DNI_Alumno?: true
    Evaluacion_ID?: true
  }

  export type NotasMaxAggregateInputType = {
    Notas_ID?: true
    Nota?: true
    DNI_Alumno?: true
    Evaluacion_ID?: true
  }

  export type NotasCountAggregateInputType = {
    Notas_ID?: true
    Nota?: true
    DNI_Alumno?: true
    Evaluacion_ID?: true
    _all?: true
  }

  export type NotasAggregateArgs = {
    /**
     * Filter which notas to aggregate.
     */
    where?: notasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notas to fetch.
     */
    orderBy?: Enumerable<notasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notas
    **/
    _count?: true | NotasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotasMaxAggregateInputType
  }

  export type GetNotasAggregateType<T extends NotasAggregateArgs> = {
        [P in keyof T & keyof AggregateNotas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotas[P]>
      : GetScalarType<T[P], AggregateNotas[P]>
  }




  export type NotasGroupByArgs = {
    where?: notasWhereInput
    orderBy?: Enumerable<notasOrderByWithAggregationInput>
    by: NotasScalarFieldEnum[]
    having?: notasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotasCountAggregateInputType | true
    _avg?: NotasAvgAggregateInputType
    _sum?: NotasSumAggregateInputType
    _min?: NotasMinAggregateInputType
    _max?: NotasMaxAggregateInputType
  }


  export type NotasGroupByOutputType = {
    Notas_ID: number
    Nota: Decimal
    DNI_Alumno: number
    Evaluacion_ID: number
    _count: NotasCountAggregateOutputType | null
    _avg: NotasAvgAggregateOutputType | null
    _sum: NotasSumAggregateOutputType | null
    _min: NotasMinAggregateOutputType | null
    _max: NotasMaxAggregateOutputType | null
  }

  type GetNotasGroupByPayload<T extends NotasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NotasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotasGroupByOutputType[P]>
            : GetScalarType<T[P], NotasGroupByOutputType[P]>
        }
      >
    >


  export type notasSelect = {
    Notas_ID?: boolean
    Nota?: boolean
    DNI_Alumno?: boolean
    Evaluacion_ID?: boolean
    Alumno?: boolean | alumnoArgs
  }


  export type notasInclude = {
    Alumno?: boolean | alumnoArgs
  }

  export type notasGetPayload<S extends boolean | null | undefined | notasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? notas :
    S extends undefined ? never :
    S extends { include: any } & (notasArgs | notasFindManyArgs)
    ? notas  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Alumno' ? alumnoGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (notasArgs | notasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Alumno' ? alumnoGetPayload<S['select'][P]> | null :  P extends keyof notas ? notas[P] : never
  } 
      : notas


  type notasCountArgs = 
    Omit<notasFindManyArgs, 'select' | 'include'> & {
      select?: NotasCountAggregateInputType | true
    }

  export interface notasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Notas that matches the filter.
     * @param {notasFindUniqueArgs} args - Arguments to find a Notas
     * @example
     * // Get one Notas
     * const notas = await prisma.notas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends notasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, notasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'notas'> extends True ? Prisma__notasClient<notasGetPayload<T>> : Prisma__notasClient<notasGetPayload<T> | null, null>

    /**
     * Find one Notas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {notasFindUniqueOrThrowArgs} args - Arguments to find a Notas
     * @example
     * // Get one Notas
     * const notas = await prisma.notas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends notasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, notasFindUniqueOrThrowArgs>
    ): Prisma__notasClient<notasGetPayload<T>>

    /**
     * Find the first Notas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notasFindFirstArgs} args - Arguments to find a Notas
     * @example
     * // Get one Notas
     * const notas = await prisma.notas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends notasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, notasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'notas'> extends True ? Prisma__notasClient<notasGetPayload<T>> : Prisma__notasClient<notasGetPayload<T> | null, null>

    /**
     * Find the first Notas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notasFindFirstOrThrowArgs} args - Arguments to find a Notas
     * @example
     * // Get one Notas
     * const notas = await prisma.notas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends notasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, notasFindFirstOrThrowArgs>
    ): Prisma__notasClient<notasGetPayload<T>>

    /**
     * Find zero or more Notas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notas
     * const notas = await prisma.notas.findMany()
     * 
     * // Get first 10 Notas
     * const notas = await prisma.notas.findMany({ take: 10 })
     * 
     * // Only select the `Notas_ID`
     * const notasWithNotas_IDOnly = await prisma.notas.findMany({ select: { Notas_ID: true } })
     * 
    **/
    findMany<T extends notasFindManyArgs>(
      args?: SelectSubset<T, notasFindManyArgs>
    ): Prisma.PrismaPromise<Array<notasGetPayload<T>>>

    /**
     * Create a Notas.
     * @param {notasCreateArgs} args - Arguments to create a Notas.
     * @example
     * // Create one Notas
     * const Notas = await prisma.notas.create({
     *   data: {
     *     // ... data to create a Notas
     *   }
     * })
     * 
    **/
    create<T extends notasCreateArgs>(
      args: SelectSubset<T, notasCreateArgs>
    ): Prisma__notasClient<notasGetPayload<T>>

    /**
     * Create many Notas.
     *     @param {notasCreateManyArgs} args - Arguments to create many Notas.
     *     @example
     *     // Create many Notas
     *     const notas = await prisma.notas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends notasCreateManyArgs>(
      args?: SelectSubset<T, notasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notas.
     * @param {notasDeleteArgs} args - Arguments to delete one Notas.
     * @example
     * // Delete one Notas
     * const Notas = await prisma.notas.delete({
     *   where: {
     *     // ... filter to delete one Notas
     *   }
     * })
     * 
    **/
    delete<T extends notasDeleteArgs>(
      args: SelectSubset<T, notasDeleteArgs>
    ): Prisma__notasClient<notasGetPayload<T>>

    /**
     * Update one Notas.
     * @param {notasUpdateArgs} args - Arguments to update one Notas.
     * @example
     * // Update one Notas
     * const notas = await prisma.notas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends notasUpdateArgs>(
      args: SelectSubset<T, notasUpdateArgs>
    ): Prisma__notasClient<notasGetPayload<T>>

    /**
     * Delete zero or more Notas.
     * @param {notasDeleteManyArgs} args - Arguments to filter Notas to delete.
     * @example
     * // Delete a few Notas
     * const { count } = await prisma.notas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends notasDeleteManyArgs>(
      args?: SelectSubset<T, notasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notas
     * const notas = await prisma.notas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends notasUpdateManyArgs>(
      args: SelectSubset<T, notasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notas.
     * @param {notasUpsertArgs} args - Arguments to update or create a Notas.
     * @example
     * // Update or create a Notas
     * const notas = await prisma.notas.upsert({
     *   create: {
     *     // ... data to create a Notas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notas we want to update
     *   }
     * })
    **/
    upsert<T extends notasUpsertArgs>(
      args: SelectSubset<T, notasUpsertArgs>
    ): Prisma__notasClient<notasGetPayload<T>>

    /**
     * Count the number of Notas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notasCountArgs} args - Arguments to filter Notas to count.
     * @example
     * // Count the number of Notas
     * const count = await prisma.notas.count({
     *   where: {
     *     // ... the filter for the Notas we want to count
     *   }
     * })
    **/
    count<T extends notasCountArgs>(
      args?: Subset<T, notasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotasAggregateArgs>(args: Subset<T, NotasAggregateArgs>): Prisma.PrismaPromise<GetNotasAggregateType<T>>

    /**
     * Group by Notas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotasGroupByArgs['orderBy'] }
        : { orderBy?: NotasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for notas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__notasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Alumno<T extends alumnoArgs= {}>(args?: Subset<T, alumnoArgs>): Prisma__alumnoClient<alumnoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * notas base type for findUnique actions
   */
  export type notasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
    /**
     * Filter, which notas to fetch.
     */
    where: notasWhereUniqueInput
  }

  /**
   * notas findUnique
   */
  export interface notasFindUniqueArgs extends notasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * notas findUniqueOrThrow
   */
  export type notasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
    /**
     * Filter, which notas to fetch.
     */
    where: notasWhereUniqueInput
  }


  /**
   * notas base type for findFirst actions
   */
  export type notasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
    /**
     * Filter, which notas to fetch.
     */
    where?: notasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notas to fetch.
     */
    orderBy?: Enumerable<notasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notas.
     */
    cursor?: notasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notas.
     */
    distinct?: Enumerable<NotasScalarFieldEnum>
  }

  /**
   * notas findFirst
   */
  export interface notasFindFirstArgs extends notasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * notas findFirstOrThrow
   */
  export type notasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
    /**
     * Filter, which notas to fetch.
     */
    where?: notasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notas to fetch.
     */
    orderBy?: Enumerable<notasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notas.
     */
    cursor?: notasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notas.
     */
    distinct?: Enumerable<NotasScalarFieldEnum>
  }


  /**
   * notas findMany
   */
  export type notasFindManyArgs = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
    /**
     * Filter, which notas to fetch.
     */
    where?: notasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notas to fetch.
     */
    orderBy?: Enumerable<notasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notas.
     */
    cursor?: notasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notas.
     */
    skip?: number
    distinct?: Enumerable<NotasScalarFieldEnum>
  }


  /**
   * notas create
   */
  export type notasCreateArgs = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
    /**
     * The data needed to create a notas.
     */
    data: XOR<notasCreateInput, notasUncheckedCreateInput>
  }


  /**
   * notas createMany
   */
  export type notasCreateManyArgs = {
    /**
     * The data used to create many notas.
     */
    data: Enumerable<notasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * notas update
   */
  export type notasUpdateArgs = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
    /**
     * The data needed to update a notas.
     */
    data: XOR<notasUpdateInput, notasUncheckedUpdateInput>
    /**
     * Choose, which notas to update.
     */
    where: notasWhereUniqueInput
  }


  /**
   * notas updateMany
   */
  export type notasUpdateManyArgs = {
    /**
     * The data used to update notas.
     */
    data: XOR<notasUpdateManyMutationInput, notasUncheckedUpdateManyInput>
    /**
     * Filter which notas to update
     */
    where?: notasWhereInput
  }


  /**
   * notas upsert
   */
  export type notasUpsertArgs = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
    /**
     * The filter to search for the notas to update in case it exists.
     */
    where: notasWhereUniqueInput
    /**
     * In case the notas found by the `where` argument doesn't exist, create a new notas with this data.
     */
    create: XOR<notasCreateInput, notasUncheckedCreateInput>
    /**
     * In case the notas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notasUpdateInput, notasUncheckedUpdateInput>
  }


  /**
   * notas delete
   */
  export type notasDeleteArgs = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
    /**
     * Filter which notas to delete.
     */
    where: notasWhereUniqueInput
  }


  /**
   * notas deleteMany
   */
  export type notasDeleteManyArgs = {
    /**
     * Filter which notas to delete
     */
    where?: notasWhereInput
  }


  /**
   * notas without action
   */
  export type notasArgs = {
    /**
     * Select specific fields to fetch from the notas
     */
    select?: notasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notasInclude | null
  }



  /**
   * Model profesor
   */


  export type AggregateProfesor = {
    _count: ProfesorCountAggregateOutputType | null
    _avg: ProfesorAvgAggregateOutputType | null
    _sum: ProfesorSumAggregateOutputType | null
    _min: ProfesorMinAggregateOutputType | null
    _max: ProfesorMaxAggregateOutputType | null
  }

  export type ProfesorAvgAggregateOutputType = {
    DNI_Profesor: number | null
  }

  export type ProfesorSumAggregateOutputType = {
    DNI_Profesor: number | null
  }

  export type ProfesorMinAggregateOutputType = {
    DNI_Profesor: number | null
    Nombre: string | null
    Apellido: string | null
    Mail: string | null
    Contrasena: string | null
  }

  export type ProfesorMaxAggregateOutputType = {
    DNI_Profesor: number | null
    Nombre: string | null
    Apellido: string | null
    Mail: string | null
    Contrasena: string | null
  }

  export type ProfesorCountAggregateOutputType = {
    DNI_Profesor: number
    Nombre: number
    Apellido: number
    Mail: number
    Contrasena: number
    _all: number
  }


  export type ProfesorAvgAggregateInputType = {
    DNI_Profesor?: true
  }

  export type ProfesorSumAggregateInputType = {
    DNI_Profesor?: true
  }

  export type ProfesorMinAggregateInputType = {
    DNI_Profesor?: true
    Nombre?: true
    Apellido?: true
    Mail?: true
    Contrasena?: true
  }

  export type ProfesorMaxAggregateInputType = {
    DNI_Profesor?: true
    Nombre?: true
    Apellido?: true
    Mail?: true
    Contrasena?: true
  }

  export type ProfesorCountAggregateInputType = {
    DNI_Profesor?: true
    Nombre?: true
    Apellido?: true
    Mail?: true
    Contrasena?: true
    _all?: true
  }

  export type ProfesorAggregateArgs = {
    /**
     * Filter which profesor to aggregate.
     */
    where?: profesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profesors to fetch.
     */
    orderBy?: Enumerable<profesorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profesors
    **/
    _count?: true | ProfesorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfesorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfesorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfesorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfesorMaxAggregateInputType
  }

  export type GetProfesorAggregateType<T extends ProfesorAggregateArgs> = {
        [P in keyof T & keyof AggregateProfesor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfesor[P]>
      : GetScalarType<T[P], AggregateProfesor[P]>
  }




  export type ProfesorGroupByArgs = {
    where?: profesorWhereInput
    orderBy?: Enumerable<profesorOrderByWithAggregationInput>
    by: ProfesorScalarFieldEnum[]
    having?: profesorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfesorCountAggregateInputType | true
    _avg?: ProfesorAvgAggregateInputType
    _sum?: ProfesorSumAggregateInputType
    _min?: ProfesorMinAggregateInputType
    _max?: ProfesorMaxAggregateInputType
  }


  export type ProfesorGroupByOutputType = {
    DNI_Profesor: number
    Nombre: string
    Apellido: string
    Mail: string
    Contrasena: string
    _count: ProfesorCountAggregateOutputType | null
    _avg: ProfesorAvgAggregateOutputType | null
    _sum: ProfesorSumAggregateOutputType | null
    _min: ProfesorMinAggregateOutputType | null
    _max: ProfesorMaxAggregateOutputType | null
  }

  type GetProfesorGroupByPayload<T extends ProfesorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProfesorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfesorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfesorGroupByOutputType[P]>
            : GetScalarType<T[P], ProfesorGroupByOutputType[P]>
        }
      >
    >


  export type profesorSelect = {
    DNI_Profesor?: boolean
    Nombre?: boolean
    Apellido?: boolean
    Mail?: boolean
    Contrasena?: boolean
    cursos?: boolean | profesor$cursosArgs
    _count?: boolean | ProfesorCountOutputTypeArgs
  }


  export type profesorInclude = {
    cursos?: boolean | profesor$cursosArgs
    _count?: boolean | ProfesorCountOutputTypeArgs
  }

  export type profesorGetPayload<S extends boolean | null | undefined | profesorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? profesor :
    S extends undefined ? never :
    S extends { include: any } & (profesorArgs | profesorFindManyArgs)
    ? profesor  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cursos' ? Array < ClaseGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProfesorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (profesorArgs | profesorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cursos' ? Array < ClaseGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProfesorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof profesor ? profesor[P] : never
  } 
      : profesor


  type profesorCountArgs = 
    Omit<profesorFindManyArgs, 'select' | 'include'> & {
      select?: ProfesorCountAggregateInputType | true
    }

  export interface profesorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Profesor that matches the filter.
     * @param {profesorFindUniqueArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends profesorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, profesorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'profesor'> extends True ? Prisma__profesorClient<profesorGetPayload<T>> : Prisma__profesorClient<profesorGetPayload<T> | null, null>

    /**
     * Find one Profesor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {profesorFindUniqueOrThrowArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends profesorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, profesorFindUniqueOrThrowArgs>
    ): Prisma__profesorClient<profesorGetPayload<T>>

    /**
     * Find the first Profesor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profesorFindFirstArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends profesorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, profesorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'profesor'> extends True ? Prisma__profesorClient<profesorGetPayload<T>> : Prisma__profesorClient<profesorGetPayload<T> | null, null>

    /**
     * Find the first Profesor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profesorFindFirstOrThrowArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends profesorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, profesorFindFirstOrThrowArgs>
    ): Prisma__profesorClient<profesorGetPayload<T>>

    /**
     * Find zero or more Profesors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profesorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profesors
     * const profesors = await prisma.profesor.findMany()
     * 
     * // Get first 10 Profesors
     * const profesors = await prisma.profesor.findMany({ take: 10 })
     * 
     * // Only select the `DNI_Profesor`
     * const profesorWithDNI_ProfesorOnly = await prisma.profesor.findMany({ select: { DNI_Profesor: true } })
     * 
    **/
    findMany<T extends profesorFindManyArgs>(
      args?: SelectSubset<T, profesorFindManyArgs>
    ): Prisma.PrismaPromise<Array<profesorGetPayload<T>>>

    /**
     * Create a Profesor.
     * @param {profesorCreateArgs} args - Arguments to create a Profesor.
     * @example
     * // Create one Profesor
     * const Profesor = await prisma.profesor.create({
     *   data: {
     *     // ... data to create a Profesor
     *   }
     * })
     * 
    **/
    create<T extends profesorCreateArgs>(
      args: SelectSubset<T, profesorCreateArgs>
    ): Prisma__profesorClient<profesorGetPayload<T>>

    /**
     * Create many Profesors.
     *     @param {profesorCreateManyArgs} args - Arguments to create many Profesors.
     *     @example
     *     // Create many Profesors
     *     const profesor = await prisma.profesor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends profesorCreateManyArgs>(
      args?: SelectSubset<T, profesorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profesor.
     * @param {profesorDeleteArgs} args - Arguments to delete one Profesor.
     * @example
     * // Delete one Profesor
     * const Profesor = await prisma.profesor.delete({
     *   where: {
     *     // ... filter to delete one Profesor
     *   }
     * })
     * 
    **/
    delete<T extends profesorDeleteArgs>(
      args: SelectSubset<T, profesorDeleteArgs>
    ): Prisma__profesorClient<profesorGetPayload<T>>

    /**
     * Update one Profesor.
     * @param {profesorUpdateArgs} args - Arguments to update one Profesor.
     * @example
     * // Update one Profesor
     * const profesor = await prisma.profesor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends profesorUpdateArgs>(
      args: SelectSubset<T, profesorUpdateArgs>
    ): Prisma__profesorClient<profesorGetPayload<T>>

    /**
     * Delete zero or more Profesors.
     * @param {profesorDeleteManyArgs} args - Arguments to filter Profesors to delete.
     * @example
     * // Delete a few Profesors
     * const { count } = await prisma.profesor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends profesorDeleteManyArgs>(
      args?: SelectSubset<T, profesorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profesors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profesorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profesors
     * const profesor = await prisma.profesor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends profesorUpdateManyArgs>(
      args: SelectSubset<T, profesorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profesor.
     * @param {profesorUpsertArgs} args - Arguments to update or create a Profesor.
     * @example
     * // Update or create a Profesor
     * const profesor = await prisma.profesor.upsert({
     *   create: {
     *     // ... data to create a Profesor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profesor we want to update
     *   }
     * })
    **/
    upsert<T extends profesorUpsertArgs>(
      args: SelectSubset<T, profesorUpsertArgs>
    ): Prisma__profesorClient<profesorGetPayload<T>>

    /**
     * Count the number of Profesors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profesorCountArgs} args - Arguments to filter Profesors to count.
     * @example
     * // Count the number of Profesors
     * const count = await prisma.profesor.count({
     *   where: {
     *     // ... the filter for the Profesors we want to count
     *   }
     * })
    **/
    count<T extends profesorCountArgs>(
      args?: Subset<T, profesorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfesorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profesor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfesorAggregateArgs>(args: Subset<T, ProfesorAggregateArgs>): Prisma.PrismaPromise<GetProfesorAggregateType<T>>

    /**
     * Group by Profesor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfesorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfesorGroupByArgs['orderBy'] }
        : { orderBy?: ProfesorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfesorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfesorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for profesor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__profesorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cursos<T extends profesor$cursosArgs= {}>(args?: Subset<T, profesor$cursosArgs>): Prisma.PrismaPromise<Array<ClaseGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * profesor base type for findUnique actions
   */
  export type profesorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the profesor
     */
    select?: profesorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profesorInclude | null
    /**
     * Filter, which profesor to fetch.
     */
    where: profesorWhereUniqueInput
  }

  /**
   * profesor findUnique
   */
  export interface profesorFindUniqueArgs extends profesorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * profesor findUniqueOrThrow
   */
  export type profesorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the profesor
     */
    select?: profesorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profesorInclude | null
    /**
     * Filter, which profesor to fetch.
     */
    where: profesorWhereUniqueInput
  }


  /**
   * profesor base type for findFirst actions
   */
  export type profesorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the profesor
     */
    select?: profesorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profesorInclude | null
    /**
     * Filter, which profesor to fetch.
     */
    where?: profesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profesors to fetch.
     */
    orderBy?: Enumerable<profesorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profesors.
     */
    cursor?: profesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profesors.
     */
    distinct?: Enumerable<ProfesorScalarFieldEnum>
  }

  /**
   * profesor findFirst
   */
  export interface profesorFindFirstArgs extends profesorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * profesor findFirstOrThrow
   */
  export type profesorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the profesor
     */
    select?: profesorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profesorInclude | null
    /**
     * Filter, which profesor to fetch.
     */
    where?: profesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profesors to fetch.
     */
    orderBy?: Enumerable<profesorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profesors.
     */
    cursor?: profesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profesors.
     */
    distinct?: Enumerable<ProfesorScalarFieldEnum>
  }


  /**
   * profesor findMany
   */
  export type profesorFindManyArgs = {
    /**
     * Select specific fields to fetch from the profesor
     */
    select?: profesorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profesorInclude | null
    /**
     * Filter, which profesors to fetch.
     */
    where?: profesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profesors to fetch.
     */
    orderBy?: Enumerable<profesorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profesors.
     */
    cursor?: profesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profesors.
     */
    skip?: number
    distinct?: Enumerable<ProfesorScalarFieldEnum>
  }


  /**
   * profesor create
   */
  export type profesorCreateArgs = {
    /**
     * Select specific fields to fetch from the profesor
     */
    select?: profesorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profesorInclude | null
    /**
     * The data needed to create a profesor.
     */
    data: XOR<profesorCreateInput, profesorUncheckedCreateInput>
  }


  /**
   * profesor createMany
   */
  export type profesorCreateManyArgs = {
    /**
     * The data used to create many profesors.
     */
    data: Enumerable<profesorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * profesor update
   */
  export type profesorUpdateArgs = {
    /**
     * Select specific fields to fetch from the profesor
     */
    select?: profesorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profesorInclude | null
    /**
     * The data needed to update a profesor.
     */
    data: XOR<profesorUpdateInput, profesorUncheckedUpdateInput>
    /**
     * Choose, which profesor to update.
     */
    where: profesorWhereUniqueInput
  }


  /**
   * profesor updateMany
   */
  export type profesorUpdateManyArgs = {
    /**
     * The data used to update profesors.
     */
    data: XOR<profesorUpdateManyMutationInput, profesorUncheckedUpdateManyInput>
    /**
     * Filter which profesors to update
     */
    where?: profesorWhereInput
  }


  /**
   * profesor upsert
   */
  export type profesorUpsertArgs = {
    /**
     * Select specific fields to fetch from the profesor
     */
    select?: profesorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profesorInclude | null
    /**
     * The filter to search for the profesor to update in case it exists.
     */
    where: profesorWhereUniqueInput
    /**
     * In case the profesor found by the `where` argument doesn't exist, create a new profesor with this data.
     */
    create: XOR<profesorCreateInput, profesorUncheckedCreateInput>
    /**
     * In case the profesor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profesorUpdateInput, profesorUncheckedUpdateInput>
  }


  /**
   * profesor delete
   */
  export type profesorDeleteArgs = {
    /**
     * Select specific fields to fetch from the profesor
     */
    select?: profesorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profesorInclude | null
    /**
     * Filter which profesor to delete.
     */
    where: profesorWhereUniqueInput
  }


  /**
   * profesor deleteMany
   */
  export type profesorDeleteManyArgs = {
    /**
     * Filter which profesors to delete
     */
    where?: profesorWhereInput
  }


  /**
   * profesor.cursos
   */
  export type profesor$cursosArgs = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaseInclude | null
    where?: ClaseWhereInput
    orderBy?: Enumerable<ClaseOrderByWithRelationInput>
    cursor?: ClaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClaseScalarFieldEnum>
  }


  /**
   * profesor without action
   */
  export type profesorArgs = {
    /**
     * Select specific fields to fetch from the profesor
     */
    select?: profesorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profesorInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdministracionScalarFieldEnum: {
    DNI_Admin: 'DNI_Admin',
    Nombre: 'Nombre',
    Apellido: 'Apellido',
    Mail: 'Mail',
    Contrasena: 'Contrasena'
  };

  export type AdministracionScalarFieldEnum = (typeof AdministracionScalarFieldEnum)[keyof typeof AdministracionScalarFieldEnum]


  export const AlumnoScalarFieldEnum: {
    Dni_Alumno: 'Dni_Alumno',
    Nombre: 'Nombre',
    Apellido: 'Apellido',
    Mail: 'Mail',
    contrasena: 'contrasena'
  };

  export type AlumnoScalarFieldEnum = (typeof AlumnoScalarFieldEnum)[keyof typeof AlumnoScalarFieldEnum]


  export const ClaseScalarFieldEnum: {
    Clase_ID: 'Clase_ID',
    Division_ID: 'Division_ID',
    Materia_ID: 'Materia_ID',
    Profesor_ID: 'Profesor_ID',
    Fecha_Comienzo: 'Fecha_Comienzo',
    Fecha_Final: 'Fecha_Final'
  };

  export type ClaseScalarFieldEnum = (typeof ClaseScalarFieldEnum)[keyof typeof ClaseScalarFieldEnum]


  export const DivisionScalarFieldEnum: {
    Division_ID: 'Division_ID',
    Ano_Escolar: 'Ano_Escolar',
    Division_Escolar: 'Division_Escolar',
    Turno: 'Turno'
  };

  export type DivisionScalarFieldEnum = (typeof DivisionScalarFieldEnum)[keyof typeof DivisionScalarFieldEnum]


  export const Divison_de_alumnoScalarFieldEnum: {
    DivisionDA_ID: 'DivisionDA_ID',
    DNi_Alumno: 'DNi_Alumno',
    Division_ID: 'Division_ID',
    Anio_Calendario: 'Anio_Calendario'
  };

  export type Divison_de_alumnoScalarFieldEnum = (typeof Divison_de_alumnoScalarFieldEnum)[keyof typeof Divison_de_alumnoScalarFieldEnum]


  export const EvaluacionesScalarFieldEnum: {
    Evaluacion_ID: 'Evaluacion_ID',
    Clase_ID: 'Clase_ID',
    Fecha: 'Fecha',
    Detalles: 'Detalles'
  };

  export type EvaluacionesScalarFieldEnum = (typeof EvaluacionesScalarFieldEnum)[keyof typeof EvaluacionesScalarFieldEnum]


  export const FaltasScalarFieldEnum: {
    Falta_ID: 'Falta_ID',
    DNI_Alumno: 'DNI_Alumno',
    Fecha: 'Fecha',
    Tipo: 'Tipo',
    jutificada: 'jutificada'
  };

  export type FaltasScalarFieldEnum = (typeof FaltasScalarFieldEnum)[keyof typeof FaltasScalarFieldEnum]


  export const MateriaScalarFieldEnum: {
    Materia_ID: 'Materia_ID',
    Nombre: 'Nombre',
    Ano_escolar: 'Ano_escolar',
    Horas_Semanales: 'Horas_Semanales'
  };

  export type MateriaScalarFieldEnum = (typeof MateriaScalarFieldEnum)[keyof typeof MateriaScalarFieldEnum]


  export const NotasScalarFieldEnum: {
    Notas_ID: 'Notas_ID',
    Nota: 'Nota',
    DNI_Alumno: 'DNI_Alumno',
    Evaluacion_ID: 'Evaluacion_ID'
  };

  export type NotasScalarFieldEnum = (typeof NotasScalarFieldEnum)[keyof typeof NotasScalarFieldEnum]


  export const ProfesorScalarFieldEnum: {
    DNI_Profesor: 'DNI_Profesor',
    Nombre: 'Nombre',
    Apellido: 'Apellido',
    Mail: 'Mail',
    Contrasena: 'Contrasena'
  };

  export type ProfesorScalarFieldEnum = (typeof ProfesorScalarFieldEnum)[keyof typeof ProfesorScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type administracionWhereInput = {
    AND?: Enumerable<administracionWhereInput>
    OR?: Enumerable<administracionWhereInput>
    NOT?: Enumerable<administracionWhereInput>
    DNI_Admin?: IntFilter | number
    Nombre?: StringFilter | string
    Apellido?: StringFilter | string
    Mail?: StringFilter | string
    Contrasena?: StringFilter | string
  }

  export type administracionOrderByWithRelationInput = {
    DNI_Admin?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    Contrasena?: SortOrder
  }

  export type administracionWhereUniqueInput = {
    DNI_Admin?: number
  }

  export type administracionOrderByWithAggregationInput = {
    DNI_Admin?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    Contrasena?: SortOrder
    _count?: administracionCountOrderByAggregateInput
    _avg?: administracionAvgOrderByAggregateInput
    _max?: administracionMaxOrderByAggregateInput
    _min?: administracionMinOrderByAggregateInput
    _sum?: administracionSumOrderByAggregateInput
  }

  export type administracionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<administracionScalarWhereWithAggregatesInput>
    OR?: Enumerable<administracionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<administracionScalarWhereWithAggregatesInput>
    DNI_Admin?: IntWithAggregatesFilter | number
    Nombre?: StringWithAggregatesFilter | string
    Apellido?: StringWithAggregatesFilter | string
    Mail?: StringWithAggregatesFilter | string
    Contrasena?: StringWithAggregatesFilter | string
  }

  export type alumnoWhereInput = {
    AND?: Enumerable<alumnoWhereInput>
    OR?: Enumerable<alumnoWhereInput>
    NOT?: Enumerable<alumnoWhereInput>
    Dni_Alumno?: IntFilter | number
    Nombre?: StringNullableFilter | string | null
    Apellido?: StringNullableFilter | string | null
    Mail?: StringNullableFilter | string | null
    contrasena?: StringFilter | string
    divisiones?: Divison_de_alumnoListRelationFilter
    notas?: NotasListRelationFilter
    faltas?: FaltasListRelationFilter
  }

  export type alumnoOrderByWithRelationInput = {
    Dni_Alumno?: SortOrder
    Nombre?: SortOrderInput | SortOrder
    Apellido?: SortOrderInput | SortOrder
    Mail?: SortOrderInput | SortOrder
    contrasena?: SortOrder
    divisiones?: divison_de_alumnoOrderByRelationAggregateInput
    notas?: notasOrderByRelationAggregateInput
    faltas?: faltasOrderByRelationAggregateInput
  }

  export type alumnoWhereUniqueInput = {
    Dni_Alumno?: number
  }

  export type alumnoOrderByWithAggregationInput = {
    Dni_Alumno?: SortOrder
    Nombre?: SortOrderInput | SortOrder
    Apellido?: SortOrderInput | SortOrder
    Mail?: SortOrderInput | SortOrder
    contrasena?: SortOrder
    _count?: alumnoCountOrderByAggregateInput
    _avg?: alumnoAvgOrderByAggregateInput
    _max?: alumnoMaxOrderByAggregateInput
    _min?: alumnoMinOrderByAggregateInput
    _sum?: alumnoSumOrderByAggregateInput
  }

  export type alumnoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<alumnoScalarWhereWithAggregatesInput>
    OR?: Enumerable<alumnoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<alumnoScalarWhereWithAggregatesInput>
    Dni_Alumno?: IntWithAggregatesFilter | number
    Nombre?: StringNullableWithAggregatesFilter | string | null
    Apellido?: StringNullableWithAggregatesFilter | string | null
    Mail?: StringNullableWithAggregatesFilter | string | null
    contrasena?: StringWithAggregatesFilter | string
  }

  export type ClaseWhereInput = {
    AND?: Enumerable<ClaseWhereInput>
    OR?: Enumerable<ClaseWhereInput>
    NOT?: Enumerable<ClaseWhereInput>
    Clase_ID?: IntFilter | number
    Division_ID?: IntFilter | number
    Materia_ID?: IntFilter | number
    Profesor_ID?: IntFilter | number
    Fecha_Comienzo?: DateTimeNullableFilter | Date | string | null
    Fecha_Final?: DateTimeNullableFilter | Date | string | null
    Division?: XOR<DivisionRelationFilter, divisionWhereInput> | null
    Materia?: XOR<MateriaRelationFilter, materiaWhereInput> | null
    Profesor?: XOR<ProfesorRelationFilter, profesorWhereInput> | null
  }

  export type ClaseOrderByWithRelationInput = {
    Clase_ID?: SortOrder
    Division_ID?: SortOrder
    Materia_ID?: SortOrder
    Profesor_ID?: SortOrder
    Fecha_Comienzo?: SortOrderInput | SortOrder
    Fecha_Final?: SortOrderInput | SortOrder
    Division?: divisionOrderByWithRelationInput
    Materia?: materiaOrderByWithRelationInput
    Profesor?: profesorOrderByWithRelationInput
  }

  export type ClaseWhereUniqueInput = {
    Clase_ID?: number
    Materia_ID?: number
  }

  export type ClaseOrderByWithAggregationInput = {
    Clase_ID?: SortOrder
    Division_ID?: SortOrder
    Materia_ID?: SortOrder
    Profesor_ID?: SortOrder
    Fecha_Comienzo?: SortOrderInput | SortOrder
    Fecha_Final?: SortOrderInput | SortOrder
    _count?: ClaseCountOrderByAggregateInput
    _avg?: ClaseAvgOrderByAggregateInput
    _max?: ClaseMaxOrderByAggregateInput
    _min?: ClaseMinOrderByAggregateInput
    _sum?: ClaseSumOrderByAggregateInput
  }

  export type ClaseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClaseScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClaseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClaseScalarWhereWithAggregatesInput>
    Clase_ID?: IntWithAggregatesFilter | number
    Division_ID?: IntWithAggregatesFilter | number
    Materia_ID?: IntWithAggregatesFilter | number
    Profesor_ID?: IntWithAggregatesFilter | number
    Fecha_Comienzo?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Fecha_Final?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type divisionWhereInput = {
    AND?: Enumerable<divisionWhereInput>
    OR?: Enumerable<divisionWhereInput>
    NOT?: Enumerable<divisionWhereInput>
    Division_ID?: IntFilter | number
    Ano_Escolar?: StringFilter | string
    Division_Escolar?: IntFilter | number
    Turno?: StringFilter | string
    Materias?: ClaseListRelationFilter
  }

  export type divisionOrderByWithRelationInput = {
    Division_ID?: SortOrder
    Ano_Escolar?: SortOrder
    Division_Escolar?: SortOrder
    Turno?: SortOrder
    Materias?: ClaseOrderByRelationAggregateInput
  }

  export type divisionWhereUniqueInput = {
    Division_ID?: number
  }

  export type divisionOrderByWithAggregationInput = {
    Division_ID?: SortOrder
    Ano_Escolar?: SortOrder
    Division_Escolar?: SortOrder
    Turno?: SortOrder
    _count?: divisionCountOrderByAggregateInput
    _avg?: divisionAvgOrderByAggregateInput
    _max?: divisionMaxOrderByAggregateInput
    _min?: divisionMinOrderByAggregateInput
    _sum?: divisionSumOrderByAggregateInput
  }

  export type divisionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<divisionScalarWhereWithAggregatesInput>
    OR?: Enumerable<divisionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<divisionScalarWhereWithAggregatesInput>
    Division_ID?: IntWithAggregatesFilter | number
    Ano_Escolar?: StringWithAggregatesFilter | string
    Division_Escolar?: IntWithAggregatesFilter | number
    Turno?: StringWithAggregatesFilter | string
  }

  export type divison_de_alumnoWhereInput = {
    AND?: Enumerable<divison_de_alumnoWhereInput>
    OR?: Enumerable<divison_de_alumnoWhereInput>
    NOT?: Enumerable<divison_de_alumnoWhereInput>
    DivisionDA_ID?: IntFilter | number
    DNi_Alumno?: IntNullableFilter | number | null
    Division_ID?: IntFilter | number
    Anio_Calendario?: IntFilter | number
    Alumno?: XOR<AlumnoRelationFilter, alumnoWhereInput> | null
  }

  export type divison_de_alumnoOrderByWithRelationInput = {
    DivisionDA_ID?: SortOrder
    DNi_Alumno?: SortOrderInput | SortOrder
    Division_ID?: SortOrder
    Anio_Calendario?: SortOrder
    Alumno?: alumnoOrderByWithRelationInput
  }

  export type divison_de_alumnoWhereUniqueInput = {
    DivisionDA_ID?: number
  }

  export type divison_de_alumnoOrderByWithAggregationInput = {
    DivisionDA_ID?: SortOrder
    DNi_Alumno?: SortOrderInput | SortOrder
    Division_ID?: SortOrder
    Anio_Calendario?: SortOrder
    _count?: divison_de_alumnoCountOrderByAggregateInput
    _avg?: divison_de_alumnoAvgOrderByAggregateInput
    _max?: divison_de_alumnoMaxOrderByAggregateInput
    _min?: divison_de_alumnoMinOrderByAggregateInput
    _sum?: divison_de_alumnoSumOrderByAggregateInput
  }

  export type divison_de_alumnoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<divison_de_alumnoScalarWhereWithAggregatesInput>
    OR?: Enumerable<divison_de_alumnoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<divison_de_alumnoScalarWhereWithAggregatesInput>
    DivisionDA_ID?: IntWithAggregatesFilter | number
    DNi_Alumno?: IntNullableWithAggregatesFilter | number | null
    Division_ID?: IntWithAggregatesFilter | number
    Anio_Calendario?: IntWithAggregatesFilter | number
  }

  export type evaluacionesWhereInput = {
    AND?: Enumerable<evaluacionesWhereInput>
    OR?: Enumerable<evaluacionesWhereInput>
    NOT?: Enumerable<evaluacionesWhereInput>
    Evaluacion_ID?: IntFilter | number
    Clase_ID?: IntFilter | number
    Fecha?: DateTimeNullableFilter | Date | string | null
    Detalles?: StringFilter | string
  }

  export type evaluacionesOrderByWithRelationInput = {
    Evaluacion_ID?: SortOrder
    Clase_ID?: SortOrder
    Fecha?: SortOrderInput | SortOrder
    Detalles?: SortOrder
  }

  export type evaluacionesWhereUniqueInput = {
    Evaluacion_ID?: number
  }

  export type evaluacionesOrderByWithAggregationInput = {
    Evaluacion_ID?: SortOrder
    Clase_ID?: SortOrder
    Fecha?: SortOrderInput | SortOrder
    Detalles?: SortOrder
    _count?: evaluacionesCountOrderByAggregateInput
    _avg?: evaluacionesAvgOrderByAggregateInput
    _max?: evaluacionesMaxOrderByAggregateInput
    _min?: evaluacionesMinOrderByAggregateInput
    _sum?: evaluacionesSumOrderByAggregateInput
  }

  export type evaluacionesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<evaluacionesScalarWhereWithAggregatesInput>
    OR?: Enumerable<evaluacionesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<evaluacionesScalarWhereWithAggregatesInput>
    Evaluacion_ID?: IntWithAggregatesFilter | number
    Clase_ID?: IntWithAggregatesFilter | number
    Fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Detalles?: StringWithAggregatesFilter | string
  }

  export type faltasWhereInput = {
    AND?: Enumerable<faltasWhereInput>
    OR?: Enumerable<faltasWhereInput>
    NOT?: Enumerable<faltasWhereInput>
    Falta_ID?: IntFilter | number
    DNI_Alumno?: IntFilter | number
    Fecha?: DateTimeNullableFilter | Date | string | null
    Tipo?: DecimalFilter | Decimal | DecimalJsLike | number | string
    jutificada?: BoolFilter | boolean
    Alumno?: XOR<AlumnoRelationFilter, alumnoWhereInput> | null
  }

  export type faltasOrderByWithRelationInput = {
    Falta_ID?: SortOrder
    DNI_Alumno?: SortOrder
    Fecha?: SortOrderInput | SortOrder
    Tipo?: SortOrder
    jutificada?: SortOrder
    Alumno?: alumnoOrderByWithRelationInput
  }

  export type faltasWhereUniqueInput = {
    Falta_ID?: number
  }

  export type faltasOrderByWithAggregationInput = {
    Falta_ID?: SortOrder
    DNI_Alumno?: SortOrder
    Fecha?: SortOrderInput | SortOrder
    Tipo?: SortOrder
    jutificada?: SortOrder
    _count?: faltasCountOrderByAggregateInput
    _avg?: faltasAvgOrderByAggregateInput
    _max?: faltasMaxOrderByAggregateInput
    _min?: faltasMinOrderByAggregateInput
    _sum?: faltasSumOrderByAggregateInput
  }

  export type faltasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<faltasScalarWhereWithAggregatesInput>
    OR?: Enumerable<faltasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<faltasScalarWhereWithAggregatesInput>
    Falta_ID?: IntWithAggregatesFilter | number
    DNI_Alumno?: IntWithAggregatesFilter | number
    Fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Tipo?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    jutificada?: BoolWithAggregatesFilter | boolean
  }

  export type materiaWhereInput = {
    AND?: Enumerable<materiaWhereInput>
    OR?: Enumerable<materiaWhereInput>
    NOT?: Enumerable<materiaWhereInput>
    Materia_ID?: IntFilter | number
    Nombre?: StringFilter | string
    Ano_escolar?: IntFilter | number
    Horas_Semanales?: IntFilter | number
    cursos?: ClaseListRelationFilter
  }

  export type materiaOrderByWithRelationInput = {
    Materia_ID?: SortOrder
    Nombre?: SortOrder
    Ano_escolar?: SortOrder
    Horas_Semanales?: SortOrder
    cursos?: ClaseOrderByRelationAggregateInput
  }

  export type materiaWhereUniqueInput = {
    Materia_ID?: number
  }

  export type materiaOrderByWithAggregationInput = {
    Materia_ID?: SortOrder
    Nombre?: SortOrder
    Ano_escolar?: SortOrder
    Horas_Semanales?: SortOrder
    _count?: materiaCountOrderByAggregateInput
    _avg?: materiaAvgOrderByAggregateInput
    _max?: materiaMaxOrderByAggregateInput
    _min?: materiaMinOrderByAggregateInput
    _sum?: materiaSumOrderByAggregateInput
  }

  export type materiaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<materiaScalarWhereWithAggregatesInput>
    OR?: Enumerable<materiaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<materiaScalarWhereWithAggregatesInput>
    Materia_ID?: IntWithAggregatesFilter | number
    Nombre?: StringWithAggregatesFilter | string
    Ano_escolar?: IntWithAggregatesFilter | number
    Horas_Semanales?: IntWithAggregatesFilter | number
  }

  export type notasWhereInput = {
    AND?: Enumerable<notasWhereInput>
    OR?: Enumerable<notasWhereInput>
    NOT?: Enumerable<notasWhereInput>
    Notas_ID?: IntFilter | number
    Nota?: DecimalFilter | Decimal | DecimalJsLike | number | string
    DNI_Alumno?: IntFilter | number
    Evaluacion_ID?: IntFilter | number
    Alumno?: XOR<AlumnoRelationFilter, alumnoWhereInput> | null
  }

  export type notasOrderByWithRelationInput = {
    Notas_ID?: SortOrder
    Nota?: SortOrder
    DNI_Alumno?: SortOrder
    Evaluacion_ID?: SortOrder
    Alumno?: alumnoOrderByWithRelationInput
  }

  export type notasWhereUniqueInput = {
    Notas_ID?: number
    Evaluacion_ID?: number
  }

  export type notasOrderByWithAggregationInput = {
    Notas_ID?: SortOrder
    Nota?: SortOrder
    DNI_Alumno?: SortOrder
    Evaluacion_ID?: SortOrder
    _count?: notasCountOrderByAggregateInput
    _avg?: notasAvgOrderByAggregateInput
    _max?: notasMaxOrderByAggregateInput
    _min?: notasMinOrderByAggregateInput
    _sum?: notasSumOrderByAggregateInput
  }

  export type notasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<notasScalarWhereWithAggregatesInput>
    OR?: Enumerable<notasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<notasScalarWhereWithAggregatesInput>
    Notas_ID?: IntWithAggregatesFilter | number
    Nota?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    DNI_Alumno?: IntWithAggregatesFilter | number
    Evaluacion_ID?: IntWithAggregatesFilter | number
  }

  export type profesorWhereInput = {
    AND?: Enumerable<profesorWhereInput>
    OR?: Enumerable<profesorWhereInput>
    NOT?: Enumerable<profesorWhereInput>
    DNI_Profesor?: IntFilter | number
    Nombre?: StringFilter | string
    Apellido?: StringFilter | string
    Mail?: StringFilter | string
    Contrasena?: StringFilter | string
    cursos?: ClaseListRelationFilter
  }

  export type profesorOrderByWithRelationInput = {
    DNI_Profesor?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    Contrasena?: SortOrder
    cursos?: ClaseOrderByRelationAggregateInput
  }

  export type profesorWhereUniqueInput = {
    DNI_Profesor?: number
  }

  export type profesorOrderByWithAggregationInput = {
    DNI_Profesor?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    Contrasena?: SortOrder
    _count?: profesorCountOrderByAggregateInput
    _avg?: profesorAvgOrderByAggregateInput
    _max?: profesorMaxOrderByAggregateInput
    _min?: profesorMinOrderByAggregateInput
    _sum?: profesorSumOrderByAggregateInput
  }

  export type profesorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<profesorScalarWhereWithAggregatesInput>
    OR?: Enumerable<profesorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<profesorScalarWhereWithAggregatesInput>
    DNI_Profesor?: IntWithAggregatesFilter | number
    Nombre?: StringWithAggregatesFilter | string
    Apellido?: StringWithAggregatesFilter | string
    Mail?: StringWithAggregatesFilter | string
    Contrasena?: StringWithAggregatesFilter | string
  }

  export type administracionCreateInput = {
    DNI_Admin: number
    Nombre: string
    Apellido: string
    Mail: string
    Contrasena: string
  }

  export type administracionUncheckedCreateInput = {
    DNI_Admin: number
    Nombre: string
    Apellido: string
    Mail: string
    Contrasena: string
  }

  export type administracionUpdateInput = {
    DNI_Admin?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Apellido?: StringFieldUpdateOperationsInput | string
    Mail?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type administracionUncheckedUpdateInput = {
    DNI_Admin?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Apellido?: StringFieldUpdateOperationsInput | string
    Mail?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type administracionCreateManyInput = {
    DNI_Admin: number
    Nombre: string
    Apellido: string
    Mail: string
    Contrasena: string
  }

  export type administracionUpdateManyMutationInput = {
    DNI_Admin?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Apellido?: StringFieldUpdateOperationsInput | string
    Mail?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type administracionUncheckedUpdateManyInput = {
    DNI_Admin?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Apellido?: StringFieldUpdateOperationsInput | string
    Mail?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type alumnoCreateInput = {
    Dni_Alumno: number
    Nombre?: string | null
    Apellido?: string | null
    Mail?: string | null
    contrasena: string
    divisiones?: divison_de_alumnoCreateNestedManyWithoutAlumnoInput
    notas?: notasCreateNestedManyWithoutAlumnoInput
    faltas?: faltasCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoUncheckedCreateInput = {
    Dni_Alumno: number
    Nombre?: string | null
    Apellido?: string | null
    Mail?: string | null
    contrasena: string
    divisiones?: divison_de_alumnoUncheckedCreateNestedManyWithoutAlumnoInput
    notas?: notasUncheckedCreateNestedManyWithoutAlumnoInput
    faltas?: faltasUncheckedCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoUpdateInput = {
    Dni_Alumno?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Apellido?: NullableStringFieldUpdateOperationsInput | string | null
    Mail?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: StringFieldUpdateOperationsInput | string
    divisiones?: divison_de_alumnoUpdateManyWithoutAlumnoNestedInput
    notas?: notasUpdateManyWithoutAlumnoNestedInput
    faltas?: faltasUpdateManyWithoutAlumnoNestedInput
  }

  export type alumnoUncheckedUpdateInput = {
    Dni_Alumno?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Apellido?: NullableStringFieldUpdateOperationsInput | string | null
    Mail?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: StringFieldUpdateOperationsInput | string
    divisiones?: divison_de_alumnoUncheckedUpdateManyWithoutAlumnoNestedInput
    notas?: notasUncheckedUpdateManyWithoutAlumnoNestedInput
    faltas?: faltasUncheckedUpdateManyWithoutAlumnoNestedInput
  }

  export type alumnoCreateManyInput = {
    Dni_Alumno: number
    Nombre?: string | null
    Apellido?: string | null
    Mail?: string | null
    contrasena: string
  }

  export type alumnoUpdateManyMutationInput = {
    Dni_Alumno?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Apellido?: NullableStringFieldUpdateOperationsInput | string | null
    Mail?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type alumnoUncheckedUpdateManyInput = {
    Dni_Alumno?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Apellido?: NullableStringFieldUpdateOperationsInput | string | null
    Mail?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type ClaseCreateInput = {
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
    Division?: divisionCreateNestedOneWithoutMateriasInput
    Materia?: materiaCreateNestedOneWithoutCursosInput
    Profesor?: profesorCreateNestedOneWithoutCursosInput
  }

  export type ClaseUncheckedCreateInput = {
    Clase_ID?: number
    Division_ID: number
    Materia_ID: number
    Profesor_ID: number
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
  }

  export type ClaseUpdateInput = {
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Division?: divisionUpdateOneWithoutMateriasNestedInput
    Materia?: materiaUpdateOneWithoutCursosNestedInput
    Profesor?: profesorUpdateOneWithoutCursosNestedInput
  }

  export type ClaseUncheckedUpdateInput = {
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Division_ID?: IntFieldUpdateOperationsInput | number
    Materia_ID?: IntFieldUpdateOperationsInput | number
    Profesor_ID?: IntFieldUpdateOperationsInput | number
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClaseCreateManyInput = {
    Clase_ID?: number
    Division_ID: number
    Materia_ID: number
    Profesor_ID: number
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
  }

  export type ClaseUpdateManyMutationInput = {
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClaseUncheckedUpdateManyInput = {
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Division_ID?: IntFieldUpdateOperationsInput | number
    Materia_ID?: IntFieldUpdateOperationsInput | number
    Profesor_ID?: IntFieldUpdateOperationsInput | number
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type divisionCreateInput = {
    Ano_Escolar: string
    Division_Escolar: number
    Turno: string
    Materias?: ClaseCreateNestedManyWithoutDivisionInput
  }

  export type divisionUncheckedCreateInput = {
    Division_ID?: number
    Ano_Escolar: string
    Division_Escolar: number
    Turno: string
    Materias?: ClaseUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type divisionUpdateInput = {
    Ano_Escolar?: StringFieldUpdateOperationsInput | string
    Division_Escolar?: IntFieldUpdateOperationsInput | number
    Turno?: StringFieldUpdateOperationsInput | string
    Materias?: ClaseUpdateManyWithoutDivisionNestedInput
  }

  export type divisionUncheckedUpdateInput = {
    Division_ID?: IntFieldUpdateOperationsInput | number
    Ano_Escolar?: StringFieldUpdateOperationsInput | string
    Division_Escolar?: IntFieldUpdateOperationsInput | number
    Turno?: StringFieldUpdateOperationsInput | string
    Materias?: ClaseUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type divisionCreateManyInput = {
    Division_ID?: number
    Ano_Escolar: string
    Division_Escolar: number
    Turno: string
  }

  export type divisionUpdateManyMutationInput = {
    Ano_Escolar?: StringFieldUpdateOperationsInput | string
    Division_Escolar?: IntFieldUpdateOperationsInput | number
    Turno?: StringFieldUpdateOperationsInput | string
  }

  export type divisionUncheckedUpdateManyInput = {
    Division_ID?: IntFieldUpdateOperationsInput | number
    Ano_Escolar?: StringFieldUpdateOperationsInput | string
    Division_Escolar?: IntFieldUpdateOperationsInput | number
    Turno?: StringFieldUpdateOperationsInput | string
  }

  export type divison_de_alumnoCreateInput = {
    Division_ID: number
    Anio_Calendario: number
    Alumno?: alumnoCreateNestedOneWithoutDivisionesInput
  }

  export type divison_de_alumnoUncheckedCreateInput = {
    DivisionDA_ID?: number
    DNi_Alumno?: number | null
    Division_ID: number
    Anio_Calendario: number
  }

  export type divison_de_alumnoUpdateInput = {
    Division_ID?: IntFieldUpdateOperationsInput | number
    Anio_Calendario?: IntFieldUpdateOperationsInput | number
    Alumno?: alumnoUpdateOneWithoutDivisionesNestedInput
  }

  export type divison_de_alumnoUncheckedUpdateInput = {
    DivisionDA_ID?: IntFieldUpdateOperationsInput | number
    DNi_Alumno?: NullableIntFieldUpdateOperationsInput | number | null
    Division_ID?: IntFieldUpdateOperationsInput | number
    Anio_Calendario?: IntFieldUpdateOperationsInput | number
  }

  export type divison_de_alumnoCreateManyInput = {
    DivisionDA_ID?: number
    DNi_Alumno?: number | null
    Division_ID: number
    Anio_Calendario: number
  }

  export type divison_de_alumnoUpdateManyMutationInput = {
    Division_ID?: IntFieldUpdateOperationsInput | number
    Anio_Calendario?: IntFieldUpdateOperationsInput | number
  }

  export type divison_de_alumnoUncheckedUpdateManyInput = {
    DivisionDA_ID?: IntFieldUpdateOperationsInput | number
    DNi_Alumno?: NullableIntFieldUpdateOperationsInput | number | null
    Division_ID?: IntFieldUpdateOperationsInput | number
    Anio_Calendario?: IntFieldUpdateOperationsInput | number
  }

  export type evaluacionesCreateInput = {
    Clase_ID: number
    Fecha?: Date | string | null
    Detalles: string
  }

  export type evaluacionesUncheckedCreateInput = {
    Evaluacion_ID?: number
    Clase_ID: number
    Fecha?: Date | string | null
    Detalles: string
  }

  export type evaluacionesUpdateInput = {
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Detalles?: StringFieldUpdateOperationsInput | string
  }

  export type evaluacionesUncheckedUpdateInput = {
    Evaluacion_ID?: IntFieldUpdateOperationsInput | number
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Detalles?: StringFieldUpdateOperationsInput | string
  }

  export type evaluacionesCreateManyInput = {
    Evaluacion_ID?: number
    Clase_ID: number
    Fecha?: Date | string | null
    Detalles: string
  }

  export type evaluacionesUpdateManyMutationInput = {
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Detalles?: StringFieldUpdateOperationsInput | string
  }

  export type evaluacionesUncheckedUpdateManyInput = {
    Evaluacion_ID?: IntFieldUpdateOperationsInput | number
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Detalles?: StringFieldUpdateOperationsInput | string
  }

  export type faltasCreateInput = {
    Fecha?: Date | string | null
    Tipo: Decimal | DecimalJsLike | number | string
    jutificada: boolean
    Alumno?: alumnoCreateNestedOneWithoutFaltasInput
  }

  export type faltasUncheckedCreateInput = {
    Falta_ID?: number
    DNI_Alumno: number
    Fecha?: Date | string | null
    Tipo: Decimal | DecimalJsLike | number | string
    jutificada: boolean
  }

  export type faltasUpdateInput = {
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Tipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jutificada?: BoolFieldUpdateOperationsInput | boolean
    Alumno?: alumnoUpdateOneWithoutFaltasNestedInput
  }

  export type faltasUncheckedUpdateInput = {
    Falta_ID?: IntFieldUpdateOperationsInput | number
    DNI_Alumno?: IntFieldUpdateOperationsInput | number
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Tipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jutificada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type faltasCreateManyInput = {
    Falta_ID?: number
    DNI_Alumno: number
    Fecha?: Date | string | null
    Tipo: Decimal | DecimalJsLike | number | string
    jutificada: boolean
  }

  export type faltasUpdateManyMutationInput = {
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Tipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jutificada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type faltasUncheckedUpdateManyInput = {
    Falta_ID?: IntFieldUpdateOperationsInput | number
    DNI_Alumno?: IntFieldUpdateOperationsInput | number
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Tipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jutificada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type materiaCreateInput = {
    Nombre: string
    Ano_escolar: number
    Horas_Semanales: number
    cursos?: ClaseCreateNestedManyWithoutMateriaInput
  }

  export type materiaUncheckedCreateInput = {
    Materia_ID?: number
    Nombre: string
    Ano_escolar: number
    Horas_Semanales: number
    cursos?: ClaseUncheckedCreateNestedManyWithoutMateriaInput
  }

  export type materiaUpdateInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Ano_escolar?: IntFieldUpdateOperationsInput | number
    Horas_Semanales?: IntFieldUpdateOperationsInput | number
    cursos?: ClaseUpdateManyWithoutMateriaNestedInput
  }

  export type materiaUncheckedUpdateInput = {
    Materia_ID?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Ano_escolar?: IntFieldUpdateOperationsInput | number
    Horas_Semanales?: IntFieldUpdateOperationsInput | number
    cursos?: ClaseUncheckedUpdateManyWithoutMateriaNestedInput
  }

  export type materiaCreateManyInput = {
    Materia_ID?: number
    Nombre: string
    Ano_escolar: number
    Horas_Semanales: number
  }

  export type materiaUpdateManyMutationInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Ano_escolar?: IntFieldUpdateOperationsInput | number
    Horas_Semanales?: IntFieldUpdateOperationsInput | number
  }

  export type materiaUncheckedUpdateManyInput = {
    Materia_ID?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Ano_escolar?: IntFieldUpdateOperationsInput | number
    Horas_Semanales?: IntFieldUpdateOperationsInput | number
  }

  export type notasCreateInput = {
    Nota: Decimal | DecimalJsLike | number | string
    Evaluacion_ID: number
    Alumno?: alumnoCreateNestedOneWithoutNotasInput
  }

  export type notasUncheckedCreateInput = {
    Notas_ID?: number
    Nota: Decimal | DecimalJsLike | number | string
    DNI_Alumno: number
    Evaluacion_ID: number
  }

  export type notasUpdateInput = {
    Nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Evaluacion_ID?: IntFieldUpdateOperationsInput | number
    Alumno?: alumnoUpdateOneWithoutNotasNestedInput
  }

  export type notasUncheckedUpdateInput = {
    Notas_ID?: IntFieldUpdateOperationsInput | number
    Nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    DNI_Alumno?: IntFieldUpdateOperationsInput | number
    Evaluacion_ID?: IntFieldUpdateOperationsInput | number
  }

  export type notasCreateManyInput = {
    Notas_ID?: number
    Nota: Decimal | DecimalJsLike | number | string
    DNI_Alumno: number
    Evaluacion_ID: number
  }

  export type notasUpdateManyMutationInput = {
    Nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Evaluacion_ID?: IntFieldUpdateOperationsInput | number
  }

  export type notasUncheckedUpdateManyInput = {
    Notas_ID?: IntFieldUpdateOperationsInput | number
    Nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    DNI_Alumno?: IntFieldUpdateOperationsInput | number
    Evaluacion_ID?: IntFieldUpdateOperationsInput | number
  }

  export type profesorCreateInput = {
    Nombre: string
    Apellido: string
    Mail: string
    Contrasena: string
    cursos?: ClaseCreateNestedManyWithoutProfesorInput
  }

  export type profesorUncheckedCreateInput = {
    DNI_Profesor?: number
    Nombre: string
    Apellido: string
    Mail: string
    Contrasena: string
    cursos?: ClaseUncheckedCreateNestedManyWithoutProfesorInput
  }

  export type profesorUpdateInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Apellido?: StringFieldUpdateOperationsInput | string
    Mail?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
    cursos?: ClaseUpdateManyWithoutProfesorNestedInput
  }

  export type profesorUncheckedUpdateInput = {
    DNI_Profesor?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Apellido?: StringFieldUpdateOperationsInput | string
    Mail?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
    cursos?: ClaseUncheckedUpdateManyWithoutProfesorNestedInput
  }

  export type profesorCreateManyInput = {
    DNI_Profesor?: number
    Nombre: string
    Apellido: string
    Mail: string
    Contrasena: string
  }

  export type profesorUpdateManyMutationInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Apellido?: StringFieldUpdateOperationsInput | string
    Mail?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type profesorUncheckedUpdateManyInput = {
    DNI_Profesor?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Apellido?: StringFieldUpdateOperationsInput | string
    Mail?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type administracionCountOrderByAggregateInput = {
    DNI_Admin?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    Contrasena?: SortOrder
  }

  export type administracionAvgOrderByAggregateInput = {
    DNI_Admin?: SortOrder
  }

  export type administracionMaxOrderByAggregateInput = {
    DNI_Admin?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    Contrasena?: SortOrder
  }

  export type administracionMinOrderByAggregateInput = {
    DNI_Admin?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    Contrasena?: SortOrder
  }

  export type administracionSumOrderByAggregateInput = {
    DNI_Admin?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type Divison_de_alumnoListRelationFilter = {
    every?: divison_de_alumnoWhereInput
    some?: divison_de_alumnoWhereInput
    none?: divison_de_alumnoWhereInput
  }

  export type NotasListRelationFilter = {
    every?: notasWhereInput
    some?: notasWhereInput
    none?: notasWhereInput
  }

  export type FaltasListRelationFilter = {
    every?: faltasWhereInput
    some?: faltasWhereInput
    none?: faltasWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type divison_de_alumnoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type faltasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type alumnoCountOrderByAggregateInput = {
    Dni_Alumno?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    contrasena?: SortOrder
  }

  export type alumnoAvgOrderByAggregateInput = {
    Dni_Alumno?: SortOrder
  }

  export type alumnoMaxOrderByAggregateInput = {
    Dni_Alumno?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    contrasena?: SortOrder
  }

  export type alumnoMinOrderByAggregateInput = {
    Dni_Alumno?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    contrasena?: SortOrder
  }

  export type alumnoSumOrderByAggregateInput = {
    Dni_Alumno?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type DivisionRelationFilter = {
    is?: divisionWhereInput | null
    isNot?: divisionWhereInput | null
  }

  export type MateriaRelationFilter = {
    is?: materiaWhereInput | null
    isNot?: materiaWhereInput | null
  }

  export type ProfesorRelationFilter = {
    is?: profesorWhereInput | null
    isNot?: profesorWhereInput | null
  }

  export type ClaseCountOrderByAggregateInput = {
    Clase_ID?: SortOrder
    Division_ID?: SortOrder
    Materia_ID?: SortOrder
    Profesor_ID?: SortOrder
    Fecha_Comienzo?: SortOrder
    Fecha_Final?: SortOrder
  }

  export type ClaseAvgOrderByAggregateInput = {
    Clase_ID?: SortOrder
    Division_ID?: SortOrder
    Materia_ID?: SortOrder
    Profesor_ID?: SortOrder
  }

  export type ClaseMaxOrderByAggregateInput = {
    Clase_ID?: SortOrder
    Division_ID?: SortOrder
    Materia_ID?: SortOrder
    Profesor_ID?: SortOrder
    Fecha_Comienzo?: SortOrder
    Fecha_Final?: SortOrder
  }

  export type ClaseMinOrderByAggregateInput = {
    Clase_ID?: SortOrder
    Division_ID?: SortOrder
    Materia_ID?: SortOrder
    Profesor_ID?: SortOrder
    Fecha_Comienzo?: SortOrder
    Fecha_Final?: SortOrder
  }

  export type ClaseSumOrderByAggregateInput = {
    Clase_ID?: SortOrder
    Division_ID?: SortOrder
    Materia_ID?: SortOrder
    Profesor_ID?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type ClaseListRelationFilter = {
    every?: ClaseWhereInput
    some?: ClaseWhereInput
    none?: ClaseWhereInput
  }

  export type ClaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type divisionCountOrderByAggregateInput = {
    Division_ID?: SortOrder
    Ano_Escolar?: SortOrder
    Division_Escolar?: SortOrder
    Turno?: SortOrder
  }

  export type divisionAvgOrderByAggregateInput = {
    Division_ID?: SortOrder
    Division_Escolar?: SortOrder
  }

  export type divisionMaxOrderByAggregateInput = {
    Division_ID?: SortOrder
    Ano_Escolar?: SortOrder
    Division_Escolar?: SortOrder
    Turno?: SortOrder
  }

  export type divisionMinOrderByAggregateInput = {
    Division_ID?: SortOrder
    Ano_Escolar?: SortOrder
    Division_Escolar?: SortOrder
    Turno?: SortOrder
  }

  export type divisionSumOrderByAggregateInput = {
    Division_ID?: SortOrder
    Division_Escolar?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type AlumnoRelationFilter = {
    is?: alumnoWhereInput | null
    isNot?: alumnoWhereInput | null
  }

  export type divison_de_alumnoCountOrderByAggregateInput = {
    DivisionDA_ID?: SortOrder
    DNi_Alumno?: SortOrder
    Division_ID?: SortOrder
    Anio_Calendario?: SortOrder
  }

  export type divison_de_alumnoAvgOrderByAggregateInput = {
    DivisionDA_ID?: SortOrder
    DNi_Alumno?: SortOrder
    Division_ID?: SortOrder
    Anio_Calendario?: SortOrder
  }

  export type divison_de_alumnoMaxOrderByAggregateInput = {
    DivisionDA_ID?: SortOrder
    DNi_Alumno?: SortOrder
    Division_ID?: SortOrder
    Anio_Calendario?: SortOrder
  }

  export type divison_de_alumnoMinOrderByAggregateInput = {
    DivisionDA_ID?: SortOrder
    DNi_Alumno?: SortOrder
    Division_ID?: SortOrder
    Anio_Calendario?: SortOrder
  }

  export type divison_de_alumnoSumOrderByAggregateInput = {
    DivisionDA_ID?: SortOrder
    DNi_Alumno?: SortOrder
    Division_ID?: SortOrder
    Anio_Calendario?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type evaluacionesCountOrderByAggregateInput = {
    Evaluacion_ID?: SortOrder
    Clase_ID?: SortOrder
    Fecha?: SortOrder
    Detalles?: SortOrder
  }

  export type evaluacionesAvgOrderByAggregateInput = {
    Evaluacion_ID?: SortOrder
    Clase_ID?: SortOrder
  }

  export type evaluacionesMaxOrderByAggregateInput = {
    Evaluacion_ID?: SortOrder
    Clase_ID?: SortOrder
    Fecha?: SortOrder
    Detalles?: SortOrder
  }

  export type evaluacionesMinOrderByAggregateInput = {
    Evaluacion_ID?: SortOrder
    Clase_ID?: SortOrder
    Fecha?: SortOrder
    Detalles?: SortOrder
  }

  export type evaluacionesSumOrderByAggregateInput = {
    Evaluacion_ID?: SortOrder
    Clase_ID?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type faltasCountOrderByAggregateInput = {
    Falta_ID?: SortOrder
    DNI_Alumno?: SortOrder
    Fecha?: SortOrder
    Tipo?: SortOrder
    jutificada?: SortOrder
  }

  export type faltasAvgOrderByAggregateInput = {
    Falta_ID?: SortOrder
    DNI_Alumno?: SortOrder
    Tipo?: SortOrder
  }

  export type faltasMaxOrderByAggregateInput = {
    Falta_ID?: SortOrder
    DNI_Alumno?: SortOrder
    Fecha?: SortOrder
    Tipo?: SortOrder
    jutificada?: SortOrder
  }

  export type faltasMinOrderByAggregateInput = {
    Falta_ID?: SortOrder
    DNI_Alumno?: SortOrder
    Fecha?: SortOrder
    Tipo?: SortOrder
    jutificada?: SortOrder
  }

  export type faltasSumOrderByAggregateInput = {
    Falta_ID?: SortOrder
    DNI_Alumno?: SortOrder
    Tipo?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type materiaCountOrderByAggregateInput = {
    Materia_ID?: SortOrder
    Nombre?: SortOrder
    Ano_escolar?: SortOrder
    Horas_Semanales?: SortOrder
  }

  export type materiaAvgOrderByAggregateInput = {
    Materia_ID?: SortOrder
    Ano_escolar?: SortOrder
    Horas_Semanales?: SortOrder
  }

  export type materiaMaxOrderByAggregateInput = {
    Materia_ID?: SortOrder
    Nombre?: SortOrder
    Ano_escolar?: SortOrder
    Horas_Semanales?: SortOrder
  }

  export type materiaMinOrderByAggregateInput = {
    Materia_ID?: SortOrder
    Nombre?: SortOrder
    Ano_escolar?: SortOrder
    Horas_Semanales?: SortOrder
  }

  export type materiaSumOrderByAggregateInput = {
    Materia_ID?: SortOrder
    Ano_escolar?: SortOrder
    Horas_Semanales?: SortOrder
  }

  export type notasCountOrderByAggregateInput = {
    Notas_ID?: SortOrder
    Nota?: SortOrder
    DNI_Alumno?: SortOrder
    Evaluacion_ID?: SortOrder
  }

  export type notasAvgOrderByAggregateInput = {
    Notas_ID?: SortOrder
    Nota?: SortOrder
    DNI_Alumno?: SortOrder
    Evaluacion_ID?: SortOrder
  }

  export type notasMaxOrderByAggregateInput = {
    Notas_ID?: SortOrder
    Nota?: SortOrder
    DNI_Alumno?: SortOrder
    Evaluacion_ID?: SortOrder
  }

  export type notasMinOrderByAggregateInput = {
    Notas_ID?: SortOrder
    Nota?: SortOrder
    DNI_Alumno?: SortOrder
    Evaluacion_ID?: SortOrder
  }

  export type notasSumOrderByAggregateInput = {
    Notas_ID?: SortOrder
    Nota?: SortOrder
    DNI_Alumno?: SortOrder
    Evaluacion_ID?: SortOrder
  }

  export type profesorCountOrderByAggregateInput = {
    DNI_Profesor?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    Contrasena?: SortOrder
  }

  export type profesorAvgOrderByAggregateInput = {
    DNI_Profesor?: SortOrder
  }

  export type profesorMaxOrderByAggregateInput = {
    DNI_Profesor?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    Contrasena?: SortOrder
  }

  export type profesorMinOrderByAggregateInput = {
    DNI_Profesor?: SortOrder
    Nombre?: SortOrder
    Apellido?: SortOrder
    Mail?: SortOrder
    Contrasena?: SortOrder
  }

  export type profesorSumOrderByAggregateInput = {
    DNI_Profesor?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type divison_de_alumnoCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<Enumerable<divison_de_alumnoCreateWithoutAlumnoInput>, Enumerable<divison_de_alumnoUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<divison_de_alumnoCreateOrConnectWithoutAlumnoInput>
    createMany?: divison_de_alumnoCreateManyAlumnoInputEnvelope
    connect?: Enumerable<divison_de_alumnoWhereUniqueInput>
  }

  export type notasCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<Enumerable<notasCreateWithoutAlumnoInput>, Enumerable<notasUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<notasCreateOrConnectWithoutAlumnoInput>
    createMany?: notasCreateManyAlumnoInputEnvelope
    connect?: Enumerable<notasWhereUniqueInput>
  }

  export type faltasCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<Enumerable<faltasCreateWithoutAlumnoInput>, Enumerable<faltasUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<faltasCreateOrConnectWithoutAlumnoInput>
    createMany?: faltasCreateManyAlumnoInputEnvelope
    connect?: Enumerable<faltasWhereUniqueInput>
  }

  export type divison_de_alumnoUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<Enumerable<divison_de_alumnoCreateWithoutAlumnoInput>, Enumerable<divison_de_alumnoUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<divison_de_alumnoCreateOrConnectWithoutAlumnoInput>
    createMany?: divison_de_alumnoCreateManyAlumnoInputEnvelope
    connect?: Enumerable<divison_de_alumnoWhereUniqueInput>
  }

  export type notasUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<Enumerable<notasCreateWithoutAlumnoInput>, Enumerable<notasUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<notasCreateOrConnectWithoutAlumnoInput>
    createMany?: notasCreateManyAlumnoInputEnvelope
    connect?: Enumerable<notasWhereUniqueInput>
  }

  export type faltasUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<Enumerable<faltasCreateWithoutAlumnoInput>, Enumerable<faltasUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<faltasCreateOrConnectWithoutAlumnoInput>
    createMany?: faltasCreateManyAlumnoInputEnvelope
    connect?: Enumerable<faltasWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type divison_de_alumnoUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<Enumerable<divison_de_alumnoCreateWithoutAlumnoInput>, Enumerable<divison_de_alumnoUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<divison_de_alumnoCreateOrConnectWithoutAlumnoInput>
    upsert?: Enumerable<divison_de_alumnoUpsertWithWhereUniqueWithoutAlumnoInput>
    createMany?: divison_de_alumnoCreateManyAlumnoInputEnvelope
    set?: Enumerable<divison_de_alumnoWhereUniqueInput>
    disconnect?: Enumerable<divison_de_alumnoWhereUniqueInput>
    delete?: Enumerable<divison_de_alumnoWhereUniqueInput>
    connect?: Enumerable<divison_de_alumnoWhereUniqueInput>
    update?: Enumerable<divison_de_alumnoUpdateWithWhereUniqueWithoutAlumnoInput>
    updateMany?: Enumerable<divison_de_alumnoUpdateManyWithWhereWithoutAlumnoInput>
    deleteMany?: Enumerable<divison_de_alumnoScalarWhereInput>
  }

  export type notasUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<Enumerable<notasCreateWithoutAlumnoInput>, Enumerable<notasUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<notasCreateOrConnectWithoutAlumnoInput>
    upsert?: Enumerable<notasUpsertWithWhereUniqueWithoutAlumnoInput>
    createMany?: notasCreateManyAlumnoInputEnvelope
    set?: Enumerable<notasWhereUniqueInput>
    disconnect?: Enumerable<notasWhereUniqueInput>
    delete?: Enumerable<notasWhereUniqueInput>
    connect?: Enumerable<notasWhereUniqueInput>
    update?: Enumerable<notasUpdateWithWhereUniqueWithoutAlumnoInput>
    updateMany?: Enumerable<notasUpdateManyWithWhereWithoutAlumnoInput>
    deleteMany?: Enumerable<notasScalarWhereInput>
  }

  export type faltasUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<Enumerable<faltasCreateWithoutAlumnoInput>, Enumerable<faltasUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<faltasCreateOrConnectWithoutAlumnoInput>
    upsert?: Enumerable<faltasUpsertWithWhereUniqueWithoutAlumnoInput>
    createMany?: faltasCreateManyAlumnoInputEnvelope
    set?: Enumerable<faltasWhereUniqueInput>
    disconnect?: Enumerable<faltasWhereUniqueInput>
    delete?: Enumerable<faltasWhereUniqueInput>
    connect?: Enumerable<faltasWhereUniqueInput>
    update?: Enumerable<faltasUpdateWithWhereUniqueWithoutAlumnoInput>
    updateMany?: Enumerable<faltasUpdateManyWithWhereWithoutAlumnoInput>
    deleteMany?: Enumerable<faltasScalarWhereInput>
  }

  export type divison_de_alumnoUncheckedUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<Enumerable<divison_de_alumnoCreateWithoutAlumnoInput>, Enumerable<divison_de_alumnoUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<divison_de_alumnoCreateOrConnectWithoutAlumnoInput>
    upsert?: Enumerable<divison_de_alumnoUpsertWithWhereUniqueWithoutAlumnoInput>
    createMany?: divison_de_alumnoCreateManyAlumnoInputEnvelope
    set?: Enumerable<divison_de_alumnoWhereUniqueInput>
    disconnect?: Enumerable<divison_de_alumnoWhereUniqueInput>
    delete?: Enumerable<divison_de_alumnoWhereUniqueInput>
    connect?: Enumerable<divison_de_alumnoWhereUniqueInput>
    update?: Enumerable<divison_de_alumnoUpdateWithWhereUniqueWithoutAlumnoInput>
    updateMany?: Enumerable<divison_de_alumnoUpdateManyWithWhereWithoutAlumnoInput>
    deleteMany?: Enumerable<divison_de_alumnoScalarWhereInput>
  }

  export type notasUncheckedUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<Enumerable<notasCreateWithoutAlumnoInput>, Enumerable<notasUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<notasCreateOrConnectWithoutAlumnoInput>
    upsert?: Enumerable<notasUpsertWithWhereUniqueWithoutAlumnoInput>
    createMany?: notasCreateManyAlumnoInputEnvelope
    set?: Enumerable<notasWhereUniqueInput>
    disconnect?: Enumerable<notasWhereUniqueInput>
    delete?: Enumerable<notasWhereUniqueInput>
    connect?: Enumerable<notasWhereUniqueInput>
    update?: Enumerable<notasUpdateWithWhereUniqueWithoutAlumnoInput>
    updateMany?: Enumerable<notasUpdateManyWithWhereWithoutAlumnoInput>
    deleteMany?: Enumerable<notasScalarWhereInput>
  }

  export type faltasUncheckedUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<Enumerable<faltasCreateWithoutAlumnoInput>, Enumerable<faltasUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<faltasCreateOrConnectWithoutAlumnoInput>
    upsert?: Enumerable<faltasUpsertWithWhereUniqueWithoutAlumnoInput>
    createMany?: faltasCreateManyAlumnoInputEnvelope
    set?: Enumerable<faltasWhereUniqueInput>
    disconnect?: Enumerable<faltasWhereUniqueInput>
    delete?: Enumerable<faltasWhereUniqueInput>
    connect?: Enumerable<faltasWhereUniqueInput>
    update?: Enumerable<faltasUpdateWithWhereUniqueWithoutAlumnoInput>
    updateMany?: Enumerable<faltasUpdateManyWithWhereWithoutAlumnoInput>
    deleteMany?: Enumerable<faltasScalarWhereInput>
  }

  export type divisionCreateNestedOneWithoutMateriasInput = {
    create?: XOR<divisionCreateWithoutMateriasInput, divisionUncheckedCreateWithoutMateriasInput>
    connectOrCreate?: divisionCreateOrConnectWithoutMateriasInput
    connect?: divisionWhereUniqueInput
  }

  export type materiaCreateNestedOneWithoutCursosInput = {
    create?: XOR<materiaCreateWithoutCursosInput, materiaUncheckedCreateWithoutCursosInput>
    connectOrCreate?: materiaCreateOrConnectWithoutCursosInput
    connect?: materiaWhereUniqueInput
  }

  export type profesorCreateNestedOneWithoutCursosInput = {
    create?: XOR<profesorCreateWithoutCursosInput, profesorUncheckedCreateWithoutCursosInput>
    connectOrCreate?: profesorCreateOrConnectWithoutCursosInput
    connect?: profesorWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type divisionUpdateOneWithoutMateriasNestedInput = {
    create?: XOR<divisionCreateWithoutMateriasInput, divisionUncheckedCreateWithoutMateriasInput>
    connectOrCreate?: divisionCreateOrConnectWithoutMateriasInput
    upsert?: divisionUpsertWithoutMateriasInput
    disconnect?: boolean
    delete?: boolean
    connect?: divisionWhereUniqueInput
    update?: XOR<divisionUpdateWithoutMateriasInput, divisionUncheckedUpdateWithoutMateriasInput>
  }

  export type materiaUpdateOneWithoutCursosNestedInput = {
    create?: XOR<materiaCreateWithoutCursosInput, materiaUncheckedCreateWithoutCursosInput>
    connectOrCreate?: materiaCreateOrConnectWithoutCursosInput
    upsert?: materiaUpsertWithoutCursosInput
    disconnect?: boolean
    delete?: boolean
    connect?: materiaWhereUniqueInput
    update?: XOR<materiaUpdateWithoutCursosInput, materiaUncheckedUpdateWithoutCursosInput>
  }

  export type profesorUpdateOneWithoutCursosNestedInput = {
    create?: XOR<profesorCreateWithoutCursosInput, profesorUncheckedCreateWithoutCursosInput>
    connectOrCreate?: profesorCreateOrConnectWithoutCursosInput
    upsert?: profesorUpsertWithoutCursosInput
    disconnect?: boolean
    delete?: boolean
    connect?: profesorWhereUniqueInput
    update?: XOR<profesorUpdateWithoutCursosInput, profesorUncheckedUpdateWithoutCursosInput>
  }

  export type ClaseCreateNestedManyWithoutDivisionInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutDivisionInput>, Enumerable<ClaseUncheckedCreateWithoutDivisionInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutDivisionInput>
    createMany?: ClaseCreateManyDivisionInputEnvelope
    connect?: Enumerable<ClaseWhereUniqueInput>
  }

  export type ClaseUncheckedCreateNestedManyWithoutDivisionInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutDivisionInput>, Enumerable<ClaseUncheckedCreateWithoutDivisionInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutDivisionInput>
    createMany?: ClaseCreateManyDivisionInputEnvelope
    connect?: Enumerable<ClaseWhereUniqueInput>
  }

  export type ClaseUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutDivisionInput>, Enumerable<ClaseUncheckedCreateWithoutDivisionInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutDivisionInput>
    upsert?: Enumerable<ClaseUpsertWithWhereUniqueWithoutDivisionInput>
    createMany?: ClaseCreateManyDivisionInputEnvelope
    set?: Enumerable<ClaseWhereUniqueInput>
    disconnect?: Enumerable<ClaseWhereUniqueInput>
    delete?: Enumerable<ClaseWhereUniqueInput>
    connect?: Enumerable<ClaseWhereUniqueInput>
    update?: Enumerable<ClaseUpdateWithWhereUniqueWithoutDivisionInput>
    updateMany?: Enumerable<ClaseUpdateManyWithWhereWithoutDivisionInput>
    deleteMany?: Enumerable<ClaseScalarWhereInput>
  }

  export type ClaseUncheckedUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutDivisionInput>, Enumerable<ClaseUncheckedCreateWithoutDivisionInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutDivisionInput>
    upsert?: Enumerable<ClaseUpsertWithWhereUniqueWithoutDivisionInput>
    createMany?: ClaseCreateManyDivisionInputEnvelope
    set?: Enumerable<ClaseWhereUniqueInput>
    disconnect?: Enumerable<ClaseWhereUniqueInput>
    delete?: Enumerable<ClaseWhereUniqueInput>
    connect?: Enumerable<ClaseWhereUniqueInput>
    update?: Enumerable<ClaseUpdateWithWhereUniqueWithoutDivisionInput>
    updateMany?: Enumerable<ClaseUpdateManyWithWhereWithoutDivisionInput>
    deleteMany?: Enumerable<ClaseScalarWhereInput>
  }

  export type alumnoCreateNestedOneWithoutDivisionesInput = {
    create?: XOR<alumnoCreateWithoutDivisionesInput, alumnoUncheckedCreateWithoutDivisionesInput>
    connectOrCreate?: alumnoCreateOrConnectWithoutDivisionesInput
    connect?: alumnoWhereUniqueInput
  }

  export type alumnoUpdateOneWithoutDivisionesNestedInput = {
    create?: XOR<alumnoCreateWithoutDivisionesInput, alumnoUncheckedCreateWithoutDivisionesInput>
    connectOrCreate?: alumnoCreateOrConnectWithoutDivisionesInput
    upsert?: alumnoUpsertWithoutDivisionesInput
    disconnect?: boolean
    delete?: boolean
    connect?: alumnoWhereUniqueInput
    update?: XOR<alumnoUpdateWithoutDivisionesInput, alumnoUncheckedUpdateWithoutDivisionesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type alumnoCreateNestedOneWithoutFaltasInput = {
    create?: XOR<alumnoCreateWithoutFaltasInput, alumnoUncheckedCreateWithoutFaltasInput>
    connectOrCreate?: alumnoCreateOrConnectWithoutFaltasInput
    connect?: alumnoWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type alumnoUpdateOneWithoutFaltasNestedInput = {
    create?: XOR<alumnoCreateWithoutFaltasInput, alumnoUncheckedCreateWithoutFaltasInput>
    connectOrCreate?: alumnoCreateOrConnectWithoutFaltasInput
    upsert?: alumnoUpsertWithoutFaltasInput
    disconnect?: boolean
    delete?: boolean
    connect?: alumnoWhereUniqueInput
    update?: XOR<alumnoUpdateWithoutFaltasInput, alumnoUncheckedUpdateWithoutFaltasInput>
  }

  export type ClaseCreateNestedManyWithoutMateriaInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutMateriaInput>, Enumerable<ClaseUncheckedCreateWithoutMateriaInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutMateriaInput>
    createMany?: ClaseCreateManyMateriaInputEnvelope
    connect?: Enumerable<ClaseWhereUniqueInput>
  }

  export type ClaseUncheckedCreateNestedManyWithoutMateriaInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutMateriaInput>, Enumerable<ClaseUncheckedCreateWithoutMateriaInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutMateriaInput>
    createMany?: ClaseCreateManyMateriaInputEnvelope
    connect?: Enumerable<ClaseWhereUniqueInput>
  }

  export type ClaseUpdateManyWithoutMateriaNestedInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutMateriaInput>, Enumerable<ClaseUncheckedCreateWithoutMateriaInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutMateriaInput>
    upsert?: Enumerable<ClaseUpsertWithWhereUniqueWithoutMateriaInput>
    createMany?: ClaseCreateManyMateriaInputEnvelope
    set?: Enumerable<ClaseWhereUniqueInput>
    disconnect?: Enumerable<ClaseWhereUniqueInput>
    delete?: Enumerable<ClaseWhereUniqueInput>
    connect?: Enumerable<ClaseWhereUniqueInput>
    update?: Enumerable<ClaseUpdateWithWhereUniqueWithoutMateriaInput>
    updateMany?: Enumerable<ClaseUpdateManyWithWhereWithoutMateriaInput>
    deleteMany?: Enumerable<ClaseScalarWhereInput>
  }

  export type ClaseUncheckedUpdateManyWithoutMateriaNestedInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutMateriaInput>, Enumerable<ClaseUncheckedCreateWithoutMateriaInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutMateriaInput>
    upsert?: Enumerable<ClaseUpsertWithWhereUniqueWithoutMateriaInput>
    createMany?: ClaseCreateManyMateriaInputEnvelope
    set?: Enumerable<ClaseWhereUniqueInput>
    disconnect?: Enumerable<ClaseWhereUniqueInput>
    delete?: Enumerable<ClaseWhereUniqueInput>
    connect?: Enumerable<ClaseWhereUniqueInput>
    update?: Enumerable<ClaseUpdateWithWhereUniqueWithoutMateriaInput>
    updateMany?: Enumerable<ClaseUpdateManyWithWhereWithoutMateriaInput>
    deleteMany?: Enumerable<ClaseScalarWhereInput>
  }

  export type alumnoCreateNestedOneWithoutNotasInput = {
    create?: XOR<alumnoCreateWithoutNotasInput, alumnoUncheckedCreateWithoutNotasInput>
    connectOrCreate?: alumnoCreateOrConnectWithoutNotasInput
    connect?: alumnoWhereUniqueInput
  }

  export type alumnoUpdateOneWithoutNotasNestedInput = {
    create?: XOR<alumnoCreateWithoutNotasInput, alumnoUncheckedCreateWithoutNotasInput>
    connectOrCreate?: alumnoCreateOrConnectWithoutNotasInput
    upsert?: alumnoUpsertWithoutNotasInput
    disconnect?: boolean
    delete?: boolean
    connect?: alumnoWhereUniqueInput
    update?: XOR<alumnoUpdateWithoutNotasInput, alumnoUncheckedUpdateWithoutNotasInput>
  }

  export type ClaseCreateNestedManyWithoutProfesorInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutProfesorInput>, Enumerable<ClaseUncheckedCreateWithoutProfesorInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutProfesorInput>
    createMany?: ClaseCreateManyProfesorInputEnvelope
    connect?: Enumerable<ClaseWhereUniqueInput>
  }

  export type ClaseUncheckedCreateNestedManyWithoutProfesorInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutProfesorInput>, Enumerable<ClaseUncheckedCreateWithoutProfesorInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutProfesorInput>
    createMany?: ClaseCreateManyProfesorInputEnvelope
    connect?: Enumerable<ClaseWhereUniqueInput>
  }

  export type ClaseUpdateManyWithoutProfesorNestedInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutProfesorInput>, Enumerable<ClaseUncheckedCreateWithoutProfesorInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutProfesorInput>
    upsert?: Enumerable<ClaseUpsertWithWhereUniqueWithoutProfesorInput>
    createMany?: ClaseCreateManyProfesorInputEnvelope
    set?: Enumerable<ClaseWhereUniqueInput>
    disconnect?: Enumerable<ClaseWhereUniqueInput>
    delete?: Enumerable<ClaseWhereUniqueInput>
    connect?: Enumerable<ClaseWhereUniqueInput>
    update?: Enumerable<ClaseUpdateWithWhereUniqueWithoutProfesorInput>
    updateMany?: Enumerable<ClaseUpdateManyWithWhereWithoutProfesorInput>
    deleteMany?: Enumerable<ClaseScalarWhereInput>
  }

  export type ClaseUncheckedUpdateManyWithoutProfesorNestedInput = {
    create?: XOR<Enumerable<ClaseCreateWithoutProfesorInput>, Enumerable<ClaseUncheckedCreateWithoutProfesorInput>>
    connectOrCreate?: Enumerable<ClaseCreateOrConnectWithoutProfesorInput>
    upsert?: Enumerable<ClaseUpsertWithWhereUniqueWithoutProfesorInput>
    createMany?: ClaseCreateManyProfesorInputEnvelope
    set?: Enumerable<ClaseWhereUniqueInput>
    disconnect?: Enumerable<ClaseWhereUniqueInput>
    delete?: Enumerable<ClaseWhereUniqueInput>
    connect?: Enumerable<ClaseWhereUniqueInput>
    update?: Enumerable<ClaseUpdateWithWhereUniqueWithoutProfesorInput>
    updateMany?: Enumerable<ClaseUpdateManyWithWhereWithoutProfesorInput>
    deleteMany?: Enumerable<ClaseScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type divison_de_alumnoCreateWithoutAlumnoInput = {
    Division_ID: number
    Anio_Calendario: number
  }

  export type divison_de_alumnoUncheckedCreateWithoutAlumnoInput = {
    DivisionDA_ID?: number
    Division_ID: number
    Anio_Calendario: number
  }

  export type divison_de_alumnoCreateOrConnectWithoutAlumnoInput = {
    where: divison_de_alumnoWhereUniqueInput
    create: XOR<divison_de_alumnoCreateWithoutAlumnoInput, divison_de_alumnoUncheckedCreateWithoutAlumnoInput>
  }

  export type divison_de_alumnoCreateManyAlumnoInputEnvelope = {
    data: Enumerable<divison_de_alumnoCreateManyAlumnoInput>
    skipDuplicates?: boolean
  }

  export type notasCreateWithoutAlumnoInput = {
    Nota: Decimal | DecimalJsLike | number | string
    Evaluacion_ID: number
  }

  export type notasUncheckedCreateWithoutAlumnoInput = {
    Notas_ID?: number
    Nota: Decimal | DecimalJsLike | number | string
    Evaluacion_ID: number
  }

  export type notasCreateOrConnectWithoutAlumnoInput = {
    where: notasWhereUniqueInput
    create: XOR<notasCreateWithoutAlumnoInput, notasUncheckedCreateWithoutAlumnoInput>
  }

  export type notasCreateManyAlumnoInputEnvelope = {
    data: Enumerable<notasCreateManyAlumnoInput>
    skipDuplicates?: boolean
  }

  export type faltasCreateWithoutAlumnoInput = {
    Fecha?: Date | string | null
    Tipo: Decimal | DecimalJsLike | number | string
    jutificada: boolean
  }

  export type faltasUncheckedCreateWithoutAlumnoInput = {
    Falta_ID?: number
    Fecha?: Date | string | null
    Tipo: Decimal | DecimalJsLike | number | string
    jutificada: boolean
  }

  export type faltasCreateOrConnectWithoutAlumnoInput = {
    where: faltasWhereUniqueInput
    create: XOR<faltasCreateWithoutAlumnoInput, faltasUncheckedCreateWithoutAlumnoInput>
  }

  export type faltasCreateManyAlumnoInputEnvelope = {
    data: Enumerable<faltasCreateManyAlumnoInput>
    skipDuplicates?: boolean
  }

  export type divison_de_alumnoUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: divison_de_alumnoWhereUniqueInput
    update: XOR<divison_de_alumnoUpdateWithoutAlumnoInput, divison_de_alumnoUncheckedUpdateWithoutAlumnoInput>
    create: XOR<divison_de_alumnoCreateWithoutAlumnoInput, divison_de_alumnoUncheckedCreateWithoutAlumnoInput>
  }

  export type divison_de_alumnoUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: divison_de_alumnoWhereUniqueInput
    data: XOR<divison_de_alumnoUpdateWithoutAlumnoInput, divison_de_alumnoUncheckedUpdateWithoutAlumnoInput>
  }

  export type divison_de_alumnoUpdateManyWithWhereWithoutAlumnoInput = {
    where: divison_de_alumnoScalarWhereInput
    data: XOR<divison_de_alumnoUpdateManyMutationInput, divison_de_alumnoUncheckedUpdateManyWithoutDivisionesInput>
  }

  export type divison_de_alumnoScalarWhereInput = {
    AND?: Enumerable<divison_de_alumnoScalarWhereInput>
    OR?: Enumerable<divison_de_alumnoScalarWhereInput>
    NOT?: Enumerable<divison_de_alumnoScalarWhereInput>
    DivisionDA_ID?: IntFilter | number
    DNi_Alumno?: IntNullableFilter | number | null
    Division_ID?: IntFilter | number
    Anio_Calendario?: IntFilter | number
  }

  export type notasUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: notasWhereUniqueInput
    update: XOR<notasUpdateWithoutAlumnoInput, notasUncheckedUpdateWithoutAlumnoInput>
    create: XOR<notasCreateWithoutAlumnoInput, notasUncheckedCreateWithoutAlumnoInput>
  }

  export type notasUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: notasWhereUniqueInput
    data: XOR<notasUpdateWithoutAlumnoInput, notasUncheckedUpdateWithoutAlumnoInput>
  }

  export type notasUpdateManyWithWhereWithoutAlumnoInput = {
    where: notasScalarWhereInput
    data: XOR<notasUpdateManyMutationInput, notasUncheckedUpdateManyWithoutNotasInput>
  }

  export type notasScalarWhereInput = {
    AND?: Enumerable<notasScalarWhereInput>
    OR?: Enumerable<notasScalarWhereInput>
    NOT?: Enumerable<notasScalarWhereInput>
    Notas_ID?: IntFilter | number
    Nota?: DecimalFilter | Decimal | DecimalJsLike | number | string
    DNI_Alumno?: IntFilter | number
    Evaluacion_ID?: IntFilter | number
  }

  export type faltasUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: faltasWhereUniqueInput
    update: XOR<faltasUpdateWithoutAlumnoInput, faltasUncheckedUpdateWithoutAlumnoInput>
    create: XOR<faltasCreateWithoutAlumnoInput, faltasUncheckedCreateWithoutAlumnoInput>
  }

  export type faltasUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: faltasWhereUniqueInput
    data: XOR<faltasUpdateWithoutAlumnoInput, faltasUncheckedUpdateWithoutAlumnoInput>
  }

  export type faltasUpdateManyWithWhereWithoutAlumnoInput = {
    where: faltasScalarWhereInput
    data: XOR<faltasUpdateManyMutationInput, faltasUncheckedUpdateManyWithoutFaltasInput>
  }

  export type faltasScalarWhereInput = {
    AND?: Enumerable<faltasScalarWhereInput>
    OR?: Enumerable<faltasScalarWhereInput>
    NOT?: Enumerable<faltasScalarWhereInput>
    Falta_ID?: IntFilter | number
    DNI_Alumno?: IntFilter | number
    Fecha?: DateTimeNullableFilter | Date | string | null
    Tipo?: DecimalFilter | Decimal | DecimalJsLike | number | string
    jutificada?: BoolFilter | boolean
  }

  export type divisionCreateWithoutMateriasInput = {
    Ano_Escolar: string
    Division_Escolar: number
    Turno: string
  }

  export type divisionUncheckedCreateWithoutMateriasInput = {
    Division_ID?: number
    Ano_Escolar: string
    Division_Escolar: number
    Turno: string
  }

  export type divisionCreateOrConnectWithoutMateriasInput = {
    where: divisionWhereUniqueInput
    create: XOR<divisionCreateWithoutMateriasInput, divisionUncheckedCreateWithoutMateriasInput>
  }

  export type materiaCreateWithoutCursosInput = {
    Nombre: string
    Ano_escolar: number
    Horas_Semanales: number
  }

  export type materiaUncheckedCreateWithoutCursosInput = {
    Materia_ID?: number
    Nombre: string
    Ano_escolar: number
    Horas_Semanales: number
  }

  export type materiaCreateOrConnectWithoutCursosInput = {
    where: materiaWhereUniqueInput
    create: XOR<materiaCreateWithoutCursosInput, materiaUncheckedCreateWithoutCursosInput>
  }

  export type profesorCreateWithoutCursosInput = {
    Nombre: string
    Apellido: string
    Mail: string
    Contrasena: string
  }

  export type profesorUncheckedCreateWithoutCursosInput = {
    DNI_Profesor?: number
    Nombre: string
    Apellido: string
    Mail: string
    Contrasena: string
  }

  export type profesorCreateOrConnectWithoutCursosInput = {
    where: profesorWhereUniqueInput
    create: XOR<profesorCreateWithoutCursosInput, profesorUncheckedCreateWithoutCursosInput>
  }

  export type divisionUpsertWithoutMateriasInput = {
    update: XOR<divisionUpdateWithoutMateriasInput, divisionUncheckedUpdateWithoutMateriasInput>
    create: XOR<divisionCreateWithoutMateriasInput, divisionUncheckedCreateWithoutMateriasInput>
  }

  export type divisionUpdateWithoutMateriasInput = {
    Ano_Escolar?: StringFieldUpdateOperationsInput | string
    Division_Escolar?: IntFieldUpdateOperationsInput | number
    Turno?: StringFieldUpdateOperationsInput | string
  }

  export type divisionUncheckedUpdateWithoutMateriasInput = {
    Division_ID?: IntFieldUpdateOperationsInput | number
    Ano_Escolar?: StringFieldUpdateOperationsInput | string
    Division_Escolar?: IntFieldUpdateOperationsInput | number
    Turno?: StringFieldUpdateOperationsInput | string
  }

  export type materiaUpsertWithoutCursosInput = {
    update: XOR<materiaUpdateWithoutCursosInput, materiaUncheckedUpdateWithoutCursosInput>
    create: XOR<materiaCreateWithoutCursosInput, materiaUncheckedCreateWithoutCursosInput>
  }

  export type materiaUpdateWithoutCursosInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Ano_escolar?: IntFieldUpdateOperationsInput | number
    Horas_Semanales?: IntFieldUpdateOperationsInput | number
  }

  export type materiaUncheckedUpdateWithoutCursosInput = {
    Materia_ID?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Ano_escolar?: IntFieldUpdateOperationsInput | number
    Horas_Semanales?: IntFieldUpdateOperationsInput | number
  }

  export type profesorUpsertWithoutCursosInput = {
    update: XOR<profesorUpdateWithoutCursosInput, profesorUncheckedUpdateWithoutCursosInput>
    create: XOR<profesorCreateWithoutCursosInput, profesorUncheckedCreateWithoutCursosInput>
  }

  export type profesorUpdateWithoutCursosInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Apellido?: StringFieldUpdateOperationsInput | string
    Mail?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type profesorUncheckedUpdateWithoutCursosInput = {
    DNI_Profesor?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Apellido?: StringFieldUpdateOperationsInput | string
    Mail?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type ClaseCreateWithoutDivisionInput = {
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
    Materia?: materiaCreateNestedOneWithoutCursosInput
    Profesor?: profesorCreateNestedOneWithoutCursosInput
  }

  export type ClaseUncheckedCreateWithoutDivisionInput = {
    Clase_ID?: number
    Materia_ID: number
    Profesor_ID: number
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
  }

  export type ClaseCreateOrConnectWithoutDivisionInput = {
    where: ClaseWhereUniqueInput
    create: XOR<ClaseCreateWithoutDivisionInput, ClaseUncheckedCreateWithoutDivisionInput>
  }

  export type ClaseCreateManyDivisionInputEnvelope = {
    data: Enumerable<ClaseCreateManyDivisionInput>
    skipDuplicates?: boolean
  }

  export type ClaseUpsertWithWhereUniqueWithoutDivisionInput = {
    where: ClaseWhereUniqueInput
    update: XOR<ClaseUpdateWithoutDivisionInput, ClaseUncheckedUpdateWithoutDivisionInput>
    create: XOR<ClaseCreateWithoutDivisionInput, ClaseUncheckedCreateWithoutDivisionInput>
  }

  export type ClaseUpdateWithWhereUniqueWithoutDivisionInput = {
    where: ClaseWhereUniqueInput
    data: XOR<ClaseUpdateWithoutDivisionInput, ClaseUncheckedUpdateWithoutDivisionInput>
  }

  export type ClaseUpdateManyWithWhereWithoutDivisionInput = {
    where: ClaseScalarWhereInput
    data: XOR<ClaseUpdateManyMutationInput, ClaseUncheckedUpdateManyWithoutMateriasInput>
  }

  export type ClaseScalarWhereInput = {
    AND?: Enumerable<ClaseScalarWhereInput>
    OR?: Enumerable<ClaseScalarWhereInput>
    NOT?: Enumerable<ClaseScalarWhereInput>
    Clase_ID?: IntFilter | number
    Division_ID?: IntFilter | number
    Materia_ID?: IntFilter | number
    Profesor_ID?: IntFilter | number
    Fecha_Comienzo?: DateTimeNullableFilter | Date | string | null
    Fecha_Final?: DateTimeNullableFilter | Date | string | null
  }

  export type alumnoCreateWithoutDivisionesInput = {
    Dni_Alumno: number
    Nombre?: string | null
    Apellido?: string | null
    Mail?: string | null
    contrasena: string
    notas?: notasCreateNestedManyWithoutAlumnoInput
    faltas?: faltasCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoUncheckedCreateWithoutDivisionesInput = {
    Dni_Alumno: number
    Nombre?: string | null
    Apellido?: string | null
    Mail?: string | null
    contrasena: string
    notas?: notasUncheckedCreateNestedManyWithoutAlumnoInput
    faltas?: faltasUncheckedCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoCreateOrConnectWithoutDivisionesInput = {
    where: alumnoWhereUniqueInput
    create: XOR<alumnoCreateWithoutDivisionesInput, alumnoUncheckedCreateWithoutDivisionesInput>
  }

  export type alumnoUpsertWithoutDivisionesInput = {
    update: XOR<alumnoUpdateWithoutDivisionesInput, alumnoUncheckedUpdateWithoutDivisionesInput>
    create: XOR<alumnoCreateWithoutDivisionesInput, alumnoUncheckedCreateWithoutDivisionesInput>
  }

  export type alumnoUpdateWithoutDivisionesInput = {
    Dni_Alumno?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Apellido?: NullableStringFieldUpdateOperationsInput | string | null
    Mail?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: StringFieldUpdateOperationsInput | string
    notas?: notasUpdateManyWithoutAlumnoNestedInput
    faltas?: faltasUpdateManyWithoutAlumnoNestedInput
  }

  export type alumnoUncheckedUpdateWithoutDivisionesInput = {
    Dni_Alumno?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Apellido?: NullableStringFieldUpdateOperationsInput | string | null
    Mail?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: StringFieldUpdateOperationsInput | string
    notas?: notasUncheckedUpdateManyWithoutAlumnoNestedInput
    faltas?: faltasUncheckedUpdateManyWithoutAlumnoNestedInput
  }

  export type alumnoCreateWithoutFaltasInput = {
    Dni_Alumno: number
    Nombre?: string | null
    Apellido?: string | null
    Mail?: string | null
    contrasena: string
    divisiones?: divison_de_alumnoCreateNestedManyWithoutAlumnoInput
    notas?: notasCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoUncheckedCreateWithoutFaltasInput = {
    Dni_Alumno: number
    Nombre?: string | null
    Apellido?: string | null
    Mail?: string | null
    contrasena: string
    divisiones?: divison_de_alumnoUncheckedCreateNestedManyWithoutAlumnoInput
    notas?: notasUncheckedCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoCreateOrConnectWithoutFaltasInput = {
    where: alumnoWhereUniqueInput
    create: XOR<alumnoCreateWithoutFaltasInput, alumnoUncheckedCreateWithoutFaltasInput>
  }

  export type alumnoUpsertWithoutFaltasInput = {
    update: XOR<alumnoUpdateWithoutFaltasInput, alumnoUncheckedUpdateWithoutFaltasInput>
    create: XOR<alumnoCreateWithoutFaltasInput, alumnoUncheckedCreateWithoutFaltasInput>
  }

  export type alumnoUpdateWithoutFaltasInput = {
    Dni_Alumno?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Apellido?: NullableStringFieldUpdateOperationsInput | string | null
    Mail?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: StringFieldUpdateOperationsInput | string
    divisiones?: divison_de_alumnoUpdateManyWithoutAlumnoNestedInput
    notas?: notasUpdateManyWithoutAlumnoNestedInput
  }

  export type alumnoUncheckedUpdateWithoutFaltasInput = {
    Dni_Alumno?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Apellido?: NullableStringFieldUpdateOperationsInput | string | null
    Mail?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: StringFieldUpdateOperationsInput | string
    divisiones?: divison_de_alumnoUncheckedUpdateManyWithoutAlumnoNestedInput
    notas?: notasUncheckedUpdateManyWithoutAlumnoNestedInput
  }

  export type ClaseCreateWithoutMateriaInput = {
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
    Division?: divisionCreateNestedOneWithoutMateriasInput
    Profesor?: profesorCreateNestedOneWithoutCursosInput
  }

  export type ClaseUncheckedCreateWithoutMateriaInput = {
    Clase_ID?: number
    Division_ID: number
    Profesor_ID: number
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
  }

  export type ClaseCreateOrConnectWithoutMateriaInput = {
    where: ClaseWhereUniqueInput
    create: XOR<ClaseCreateWithoutMateriaInput, ClaseUncheckedCreateWithoutMateriaInput>
  }

  export type ClaseCreateManyMateriaInputEnvelope = {
    data: Enumerable<ClaseCreateManyMateriaInput>
    skipDuplicates?: boolean
  }

  export type ClaseUpsertWithWhereUniqueWithoutMateriaInput = {
    where: ClaseWhereUniqueInput
    update: XOR<ClaseUpdateWithoutMateriaInput, ClaseUncheckedUpdateWithoutMateriaInput>
    create: XOR<ClaseCreateWithoutMateriaInput, ClaseUncheckedCreateWithoutMateriaInput>
  }

  export type ClaseUpdateWithWhereUniqueWithoutMateriaInput = {
    where: ClaseWhereUniqueInput
    data: XOR<ClaseUpdateWithoutMateriaInput, ClaseUncheckedUpdateWithoutMateriaInput>
  }

  export type ClaseUpdateManyWithWhereWithoutMateriaInput = {
    where: ClaseScalarWhereInput
    data: XOR<ClaseUpdateManyMutationInput, ClaseUncheckedUpdateManyWithoutCursosInput>
  }

  export type alumnoCreateWithoutNotasInput = {
    Dni_Alumno: number
    Nombre?: string | null
    Apellido?: string | null
    Mail?: string | null
    contrasena: string
    divisiones?: divison_de_alumnoCreateNestedManyWithoutAlumnoInput
    faltas?: faltasCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoUncheckedCreateWithoutNotasInput = {
    Dni_Alumno: number
    Nombre?: string | null
    Apellido?: string | null
    Mail?: string | null
    contrasena: string
    divisiones?: divison_de_alumnoUncheckedCreateNestedManyWithoutAlumnoInput
    faltas?: faltasUncheckedCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoCreateOrConnectWithoutNotasInput = {
    where: alumnoWhereUniqueInput
    create: XOR<alumnoCreateWithoutNotasInput, alumnoUncheckedCreateWithoutNotasInput>
  }

  export type alumnoUpsertWithoutNotasInput = {
    update: XOR<alumnoUpdateWithoutNotasInput, alumnoUncheckedUpdateWithoutNotasInput>
    create: XOR<alumnoCreateWithoutNotasInput, alumnoUncheckedCreateWithoutNotasInput>
  }

  export type alumnoUpdateWithoutNotasInput = {
    Dni_Alumno?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Apellido?: NullableStringFieldUpdateOperationsInput | string | null
    Mail?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: StringFieldUpdateOperationsInput | string
    divisiones?: divison_de_alumnoUpdateManyWithoutAlumnoNestedInput
    faltas?: faltasUpdateManyWithoutAlumnoNestedInput
  }

  export type alumnoUncheckedUpdateWithoutNotasInput = {
    Dni_Alumno?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Apellido?: NullableStringFieldUpdateOperationsInput | string | null
    Mail?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: StringFieldUpdateOperationsInput | string
    divisiones?: divison_de_alumnoUncheckedUpdateManyWithoutAlumnoNestedInput
    faltas?: faltasUncheckedUpdateManyWithoutAlumnoNestedInput
  }

  export type ClaseCreateWithoutProfesorInput = {
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
    Division?: divisionCreateNestedOneWithoutMateriasInput
    Materia?: materiaCreateNestedOneWithoutCursosInput
  }

  export type ClaseUncheckedCreateWithoutProfesorInput = {
    Clase_ID?: number
    Division_ID: number
    Materia_ID: number
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
  }

  export type ClaseCreateOrConnectWithoutProfesorInput = {
    where: ClaseWhereUniqueInput
    create: XOR<ClaseCreateWithoutProfesorInput, ClaseUncheckedCreateWithoutProfesorInput>
  }

  export type ClaseCreateManyProfesorInputEnvelope = {
    data: Enumerable<ClaseCreateManyProfesorInput>
    skipDuplicates?: boolean
  }

  export type ClaseUpsertWithWhereUniqueWithoutProfesorInput = {
    where: ClaseWhereUniqueInput
    update: XOR<ClaseUpdateWithoutProfesorInput, ClaseUncheckedUpdateWithoutProfesorInput>
    create: XOR<ClaseCreateWithoutProfesorInput, ClaseUncheckedCreateWithoutProfesorInput>
  }

  export type ClaseUpdateWithWhereUniqueWithoutProfesorInput = {
    where: ClaseWhereUniqueInput
    data: XOR<ClaseUpdateWithoutProfesorInput, ClaseUncheckedUpdateWithoutProfesorInput>
  }

  export type ClaseUpdateManyWithWhereWithoutProfesorInput = {
    where: ClaseScalarWhereInput
    data: XOR<ClaseUpdateManyMutationInput, ClaseUncheckedUpdateManyWithoutCursosInput>
  }

  export type divison_de_alumnoCreateManyAlumnoInput = {
    DivisionDA_ID?: number
    Division_ID: number
    Anio_Calendario: number
  }

  export type notasCreateManyAlumnoInput = {
    Notas_ID?: number
    Nota: Decimal | DecimalJsLike | number | string
    Evaluacion_ID: number
  }

  export type faltasCreateManyAlumnoInput = {
    Falta_ID?: number
    Fecha?: Date | string | null
    Tipo: Decimal | DecimalJsLike | number | string
    jutificada: boolean
  }

  export type divison_de_alumnoUpdateWithoutAlumnoInput = {
    Division_ID?: IntFieldUpdateOperationsInput | number
    Anio_Calendario?: IntFieldUpdateOperationsInput | number
  }

  export type divison_de_alumnoUncheckedUpdateWithoutAlumnoInput = {
    DivisionDA_ID?: IntFieldUpdateOperationsInput | number
    Division_ID?: IntFieldUpdateOperationsInput | number
    Anio_Calendario?: IntFieldUpdateOperationsInput | number
  }

  export type divison_de_alumnoUncheckedUpdateManyWithoutDivisionesInput = {
    DivisionDA_ID?: IntFieldUpdateOperationsInput | number
    Division_ID?: IntFieldUpdateOperationsInput | number
    Anio_Calendario?: IntFieldUpdateOperationsInput | number
  }

  export type notasUpdateWithoutAlumnoInput = {
    Nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Evaluacion_ID?: IntFieldUpdateOperationsInput | number
  }

  export type notasUncheckedUpdateWithoutAlumnoInput = {
    Notas_ID?: IntFieldUpdateOperationsInput | number
    Nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Evaluacion_ID?: IntFieldUpdateOperationsInput | number
  }

  export type notasUncheckedUpdateManyWithoutNotasInput = {
    Notas_ID?: IntFieldUpdateOperationsInput | number
    Nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Evaluacion_ID?: IntFieldUpdateOperationsInput | number
  }

  export type faltasUpdateWithoutAlumnoInput = {
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Tipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jutificada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type faltasUncheckedUpdateWithoutAlumnoInput = {
    Falta_ID?: IntFieldUpdateOperationsInput | number
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Tipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jutificada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type faltasUncheckedUpdateManyWithoutFaltasInput = {
    Falta_ID?: IntFieldUpdateOperationsInput | number
    Fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Tipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jutificada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClaseCreateManyDivisionInput = {
    Clase_ID?: number
    Materia_ID: number
    Profesor_ID: number
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
  }

  export type ClaseUpdateWithoutDivisionInput = {
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Materia?: materiaUpdateOneWithoutCursosNestedInput
    Profesor?: profesorUpdateOneWithoutCursosNestedInput
  }

  export type ClaseUncheckedUpdateWithoutDivisionInput = {
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Materia_ID?: IntFieldUpdateOperationsInput | number
    Profesor_ID?: IntFieldUpdateOperationsInput | number
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClaseUncheckedUpdateManyWithoutMateriasInput = {
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Materia_ID?: IntFieldUpdateOperationsInput | number
    Profesor_ID?: IntFieldUpdateOperationsInput | number
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClaseCreateManyMateriaInput = {
    Clase_ID?: number
    Division_ID: number
    Profesor_ID: number
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
  }

  export type ClaseUpdateWithoutMateriaInput = {
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Division?: divisionUpdateOneWithoutMateriasNestedInput
    Profesor?: profesorUpdateOneWithoutCursosNestedInput
  }

  export type ClaseUncheckedUpdateWithoutMateriaInput = {
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Division_ID?: IntFieldUpdateOperationsInput | number
    Profesor_ID?: IntFieldUpdateOperationsInput | number
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClaseUncheckedUpdateManyWithoutCursosInput = {
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Division_ID?: IntFieldUpdateOperationsInput | number
    Profesor_ID?: IntFieldUpdateOperationsInput | number
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClaseCreateManyProfesorInput = {
    Clase_ID?: number
    Division_ID: number
    Materia_ID: number
    Fecha_Comienzo?: Date | string | null
    Fecha_Final?: Date | string | null
  }

  export type ClaseUpdateWithoutProfesorInput = {
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Division?: divisionUpdateOneWithoutMateriasNestedInput
    Materia?: materiaUpdateOneWithoutCursosNestedInput
  }

  export type ClaseUncheckedUpdateWithoutProfesorInput = {
    Clase_ID?: IntFieldUpdateOperationsInput | number
    Division_ID?: IntFieldUpdateOperationsInput | number
    Materia_ID?: IntFieldUpdateOperationsInput | number
    Fecha_Comienzo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Fecha_Final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}